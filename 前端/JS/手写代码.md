#### 参考

https://www.cnblogs.com/chenwenhao/p/11294541.html

#### 1. 手写 new 操作符

```js
function createNew() {
  let obj = {};

  // 下面写法会修改arguments，引起副作用
  // const ctor = Array.prototype.shift.call(arguments);
  const [ctor, ...args] = arguments;
  obj.__proto__ = ctor.prototype;

  // const result = ctor.apply(obj, arguments);
  const result = ctor.apply(obj, args);
  return typeof result === 'object' ? result : obj;
}
```

#### 2. 手写 object.create

```js
// 实现 object.create()
function create(obj) {
  function F() { }
  F.prototype = obj;
  return new F();
}

```

#### 3. 手写 call

```js
Function.prototype.myCall = function () {

  if (typeof this !== 'function') {
    throw new TypeError('not funciton');
  }

  // 创建一个谁调用指向谁的环境
  const ctx = arguments[0] || window;
  ctx.fn = this;

  // arguments 为一个类数组，并非一个真的数组
  const args = [...arguments].slice(1);
  const result = ctx.fn(...args);
  delete ctx.fn;

  return result;
}
```

#### 4. 手写 apply

```js
Function.prototype.myApply = function () {

  if (typeof this !== 'function') {
    throw new TypeError('not funciton');
  }

  const ctx = arguments[0] || window;
  ctx.fn = this;

  let result;
  if (arguments[1]) {
    result = ctx.fn(...arguments[1])
  } else {
    result = ctx.fn();
  }

  delete ctx.fn;

  return result;
}
```

#### 5. 实现bind

TODO: 待改进，参考MDN polyfill方案

```js
Function.prototype.bind = function () {

  if (typeof this !== 'function') {
    throw new TypeError('not funciton');
  }

  const self = this;
  const ctx = arguments[0];
  const args = [...arguments].slice(1);
  
  function F() {
    // 函数使用 new 的情况???
    if (this instanceof F) {
      return new self(...args, ...arguments);
    } else {
      return self.apply(ctx, args.concat(...arguments))
    }
  }
  
  F.prototype = this.prototype;
  
  return F;
}
```



#### 5. 浅拷贝、深拷贝

浅拷贝可使用扩展运算符和Object.assign

简单对象的深拷贝可以使用 ` JSON.parse(JSON.stringify(obj)) ` 方式

缺点：无法很好处理拷贝对象包含 正则表达式，函数，或者undefined等值会

undefined的值会自动删除 



#### 6. 实现一个节流、防抖函数

```js
// 节流，在规定时间只触发一次
function throttle(fn, delay) {
  let prev = Date.now();
  return function() {
    let cur = Date.now(); 
    if (cur - prev > delay) {
      fn.apply(this, arguments);
      prev = Date.now();
    }
  }
}

// 防抖，在规定时间没有触发第二次则执行
function debounce(fn, delay) {
  let timer = null;

  return function () {
    const args = arguments;
    const self = this;
    clearTimeout(timer);
    timer = setTimeout(function() {
      fn.apply(self, args)
    }, delay);
  }
}

```



#### 7. instanceof 原理

```js
// instanceof
function instanceOf(obj, func) {

  let proto = obj.__proto__;

  if (proto === null) {
    return false;
  }

  while(proto !== null) {
    if (proto === func.prototype) {
      return true;
    }
    proto = proto.__proto__;
  }

  return false;
}
```



#### 8. 柯里化函数



#### 9. 实现一个基本的EventBus

下面是一个简单的实现，待改进

如何取消一个listener？

```js

class EventEmitter {
  constructor() {
    this.listeners = {};
  }

  on(type, fn) {
    console.log(this.listeners);
    if (this.listeners[type]) {
      this.listeners[type].push(fn);
    } else {
      this.listeners[type] = [fn];
    }
  }

  emit(type, ...args) {
    const listeners = this.listeners[type];
    if (listeners) {
      listeners.forEach((fn) => {
        fn.apply(this, args);
      });
    }
  }
}

var emitter = new EventEmitter();
emitter.on("console", function (a) {
  console.log(a);
});
emitter.emit("console", 1);
```

#### 10. 手写排序（冒泡，选择，插入，快排）

![冒泡排序](img/冒泡排序.gif)

**冒泡排序**

```js
function bubbleSort(arr) {
  // 需要排序的数字个数
  let n = arr.length;

  while (n > 1) {
    for (let i = 1; i < n; i += 1) {
      if (arr[i - 1] > arr[i]) {
        let temp = arr[i - 1];
        arr[i - 1] = arr[i];
        arr[i] = temp;
      }
    }
    n -= 1;
  }
}

var arr1 = [23, 1, 4, 3, 4, 77, 99, 5, 6, 3434, 3333];
bubbleSort(arr1);
console.log(arr1);
```

