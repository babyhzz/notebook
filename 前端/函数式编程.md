## 概念

### 纯函数

纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。

如slice是纯函数，而splice则不是。

#### 优点

##### 1. 可缓存性（Cacheable）

纯函数可以根据输入来做缓存，一种典型的方式是memoize技术。

```js
var squareNumber = memoize(function(x){ return x*x; });
squareNumber(4);
//=> 16
squareNumber(4); // 从缓存中读取输入值为 4 的结果
//=> 16
squareNumber(5);
//=> 25
squareNumber(5); // 从缓存中读取输入值为 5 的结果
//=> 25
```

下面是一种简单的实现：

```js
var memoize = function (f) {
  var cache = {};
  return function () {
    var arg_str = JSON.stringify(arguments);
    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);
    return cache[arg_str];
  };
};
```

##### 2. 可移植性 （Portable）

```js
// 不纯的
var signUp = function (attrs) {
  var user = saveUser(attrs);
  welcomeUser(user);
};

var saveUser = function (attrs) {
  var user = Db.save(attrs);
  // ...
};

var welcomeUser = function (user) {
  Email(user, ...);
  // ...
};
// 纯的
var signUp = function (Db, Email, attrs) {
  return function () {
    var user = saveUser(Db, attrs);
    welcomeUser(Email, user);
  };
};
var saveUser = function (Db, attrs) {
  // ...
};
var welcomeUser = function (Email, user) {
  // ...
};
```

##### 3. 可测试性（Testable）

纯函数让测试更加容易

##### 4. 合理性（Reasonable）

如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。

```js
var Immutable = require('immutable');

var decrementHP = function (player) {
  return player.set("hp", player.hp - 1);
};

var isSameTeam = function (player1, player2) {
  return player1.team === player2.team;
};

var punch = function (player, target) {
  if (isSameTeam(player, target)) {
    return target;
  } else {
    return decrementHP(target);
  }
};

var jobe = Immutable.Map({ name: "Jobe", hp: 20, team: "red" });
var michael = Immutable.Map({
  name: "Michael", hp: 20, team: "green"
});
punch(jobe, michael);
//=> Immutable.Map({name:"Michael", hp:19, team: "green"})
```

##### 5. 并行代码

可以并行运行任意函数

### 柯里化

curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

```js
var add = function(x) {
  return function(y) {
   return x + y;
  };
};
var increment = add(1);
var addTen = add(10);

increment(2);
// 3
addTen(2);
// 12
```

这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。lodash中有柯里化帮助类 `_.curry()` 

```js
var abc = function(a, b, c) {
  return [a, b, c];
};
 
var curried = _.curry(abc);
 
curried(1)(2)(3);
// => [1, 2, 3]
 
curried(1, 2)(3);
// => [1, 2, 3]
 
curried(1, 2, 3);
// => [1, 2, 3]
 
// Curried with placeholders.
curried(1)(_, 3)(2);
// => [1, 2, 3]	
```

### 代码组合

#### 函数饲养

```js
var compose = function(f,g) {
  return function(x) {
    return f(g(x));
  };
};

// 另一种实现，从右到左的数据流，类似“管道概念”
const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));
```

