## 浏览器进程

![image-20200302090656771](img/brower_process.png)

新开一个页面至少会启动如下进程：

- 浏览器进程
- 网络进程（NetworkService）
- GPU进程
- 渲染进程（隔离，但同一站点公用）

浏览器进程功能

- 浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 

- 插件进程： 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 每个插件一个，使用才创建。

- GPU进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面**都选择**采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 



## 渲染进程

渲染进程，即Renderer Process，包含如下线程：

- GUI渲染线程
  -  负责渲染浏览器界面，解析 HTML、CSS构建 DOM 树和 RenderObject 树，布局和绘制等。
  -  当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。 
  -  GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行 

- JS引擎线程
  -  Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎） 
  -  JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。 
  -  GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 

- 事件触发线程
  -  当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务**添加到事件线程中** 
  -  当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理 
  -  由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行） 

- 定时器触发线程
  -  传说中的 setInterval 与 setTimeout 所在线程 
  -  浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 
  -  因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
  -  W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms  

- 异步HTTP请求线程
  -  在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。 
  -  将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更**事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行。 

