### 缓存位置

#### memory cache

存储在内存中的缓存，不受max-age、no-cache的影响，即使不设置缓存，如果内存比较充裕，一些资源也是会被缓存。但是缓存只是暂时的，一旦关闭浏览器，缓存就释放掉，如果这个也不想要，可以设置no-store

#### disk cache

存储在硬盘中的缓存，长时效。



### 强缓存

强缓存是利用http头中的Expires和Cache-Control来控制。 强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否"命中"强缓存，若命中则直接从缓存中获取资源，**不会再与服务端发生通信**。 

+ Expires: 值为服务器返回的数据到期时间。小于该时间则直接使用缓存。但会存在客户端和服务端时间差问题。这个Http 1.0的产物，一般用Cache-Control代替。
+ Cache-Control：
  - private：客户端可以缓存
  - public：客户端和代理服务器都可以缓存
  - max-age=t：缓存内容将在t秒后失效
  - no-cache：需要使用协商缓存来验证缓存数据 
  - no-store：所有内容都不会缓存

### 协商缓存

协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。

+ Last-Modified/If-Modified-Since: 服务器会返回客户端文件的最后修改时间。客户端再此请求时会带上 If-Modified-Since，没有变更返回304，有变更则返回新的数据。（会存在修改时间虽然改了，但是内容没变的情况。）
+ Etag：  是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串可以是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。 Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。 

### 缓存优先级

上述优先级：cache-control > expires > Etag > last-modified