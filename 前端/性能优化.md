# 浏览器基础
- [「前端进阶」从多线程到Event Loop全面梳理](https://juejin.im/post/5d5b4c2df265da03dd3d73e5)

> 读上面的文章后，让我知道了不少浏览器相关知识点，说实在的自己做了一两年的前端开发了，但却很少关注这些，觉得自己有点业余了。

浏览器是多进程的，主要：
- **Browser进程**，即浏览器主进程，只有一个。负责浏览器界面显示与用户交互，网络资源管理与下载，各页面管理，Render进程的Bitmap显示
- **第三方插件进程**，每种类型对应一个
- **GPU进程**，最多一个，用于3D显示
- **渲染进程**，即Render进程，浏览器内核，主要负责页面渲染、脚本执行、事件处理。

渲染进程是多线程的，主要包含如下线程：
- **GUI渲染线程**，负责页面渲染，与JS线程互斥
- **JS引擎线程**，负责解析执行JS，单线程
- **事件触发线程**，用来管理事件，当事件触发时，将事件放入JS执行栈
- **定时触发线程**，setTimeout和setInterval所在的线程，计时完毕通知事件触发线程
- **异步Http请求线程**，处理网络请求，若有回调通知事件触发线程

JS引擎是单线程的，因为：
1. 历史原因，在JavaScript创建之时，多线程不流行，硬件支持不好
2. 多线程复杂度高，需要加锁，否则会导致DOM渲染不可预期

GUI线程与JS线程互斥因为JS是可以操作DOM的，如一边操作一边渲染，会导致渲染出现不可预期的结果

关于EventLoop，理解一些概念：
- JS 分为同步任务和异步任务，同步任务都在JS线程上执行，形成一个执行栈，JS线程只执行执行栈中的任务。
- 事件触发线程管理一个事件队列，异步任务触发条件达成，会将回调事件放到事件队列中
- 执行栈中的代码执行完毕，就会读取事件队列中的事件，添加到执行栈中，开始执
**宏任务**：可以认为每次执行栈中执行的代码是一个宏任务，宏任务和渲染是交叉进行，渲染线程会将宏任务对DOM的修改做优化。
注意setTimeout的回调属于下一次宏任务。  
**微任务**：宏任务之后，渲染之前，会将期间产生的所有微任务都执行。Promise中的then触发时（即Resolve时），将会插入微任务队列。

所以执行流程是：宏任务 -> 微任务 -> 渲染 -> 宏任务 -> 微任务 -> 渲染 -> ...



# 高性能渲染大量列表数据

- [「前端进阶」高性能渲染十万条数据(时间分片)](https://juejin.im/post/5d76f469f265da039a28aff7)
- [「前端进阶」高性能渲染十万条数据(虚拟列表)](https://juejin.im/post/5db684ddf265da4d495c40e5)

从上面文章可以得出：  
渲染大数据列表，最粗暴的做法就是一次性全部渲染，最后发现JS运行耗时很短，但是渲染阶段是瓶颈（渲染时长计算可创建一个setTimeout的异步回调）。
通过Chrome的Performance工具，可以看出耗时主要集中在 `Recaculate Style` 和 `Layout`阶段，故在列表项布局比较复杂时，这两项的耗时将增加。

故为了解决这个问题，有两种常用方法：时间分片和虚拟列表。

+ 时间分片法：定时加载一部分数据，直至全部加载完成。
> `setTimeout` 方式可以实现，但是有闪屏问题，`setTimeout` 执行时间与渲染刷新时间不一致。
> `requestAnimationFrame` 替代`setTimeout`，解决不掉不一致问题，该函数在页面需要重绘时调用。
> 进一步优化，使用`DocumentFragment`？？？
+ 虚拟列表法：
> 虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。
> 一般包含三部分，可视区域、列表总长度占位区域（形成滚动条）、渲染区域（显示的列表项）。
> 其中渲染区域会根据可视区域的滚动条的scrollTop属性，不断修正自己的需要显示的列表数据项以及top属性（或其他位移属性），
> 保证自己在可视区域内以及数据的更新。

**虚拟列表法**有两种情况：列表项高度固定、列表项高度动态高度。固定高度比较好处理，动态高度的则需要先给出预估高度，然后不断的修正数据。
上面文章中给出了解决方案。另外对于包含异步图片的列表项，则需要使用 `ResizeObserver` 来监听，但兼容的浏览器很少。

# 大文件上传
- [字节跳动面试官：请你实现一个大文件上传和断点续传](https://juejin.im/post/5dff8a26e51d4558105420ed)

总结以下要点：
* 分块上传：前端使用blob的slice方法，将大文件分割成一个个的小文件，然后并发上传，每个blob需要有一个块的标识hash（比如文件名 + index）。
后端在接收到第一个块时建立以文件名命名的文件夹，然后将每个block以hash为文件名存储。
* 合并分片：待所有分片上传完毕后，前端发送一个合并请求，然后找到对应文件夹，合并文件。
* 文件进度条的显示：监听每个blob切片的上传进度，然后合并计算整个文件的上传进度。   
* hash的生成：最好是文件内容hash，不随文件名变化。可以使用spark-md5这个库去计算。比较耗时，所以使用web-worker。以hash+下标作为切片名，hash作为切片文件夹名，hash+扩展名作为文件名
* 文件秒传，先发送一个请求（文件hash）验证文件是否存在，若存在直接提示上传成功。
* 断点续传：需要记住已上传的切片。前端/后端均可实现，前端实现会存在数据丢失。
  - 前端方式：剔除已经上传成功的request对象，只上传未成功的。
  - 后端方式：已上传成功，不用上传；部分上传成功，将已上传的切片信息返回。

# 视频流
- [为什么视频网站的视频链接地址是blob？](https://juejin.im/post/5d1ea7a8e51d454fd8057bea)

核心是运用 `URL.createObjectURL` 生成blob协议的链接。要使用BlobURL，则需要先获取原始的blob对象，但是视频很大这种方法肯定不行，
所以出现了流媒体，常用有以下两种形式：HLS和MPEG DASH。

#### HLS（HTTP Live Streaming）
Apple 公司实现的基于 HTTP 的媒体流传输协议。HLS以ts为传输格式，m3u8为索引文件（文件中包含了所要用到的ts文件名称，时长等信息，可以用播放器播放）。
优酷使用的是这种格式。

#### DASH（Dynamic Adaptive Streaming over HTTP）
DASH会通过media presentation description (MPD)将视频内容切片成一个很短的文件片段，每个切片都有多个不同的码率，DASH Client可以根据网络的情况选择一个码率进行播放，支持在不同码率之间无缝切换。
索引文件通常是mpd，文件扩展名通常是 `.m4s`。Youtube，B站使用这种方案。

#### MediaSource
如何无缝切换视频地址，可以Blob URL指向一个视频二进制数据，然后不断将下一段视频的二进制数据添加拼接进去。
要实现这个功能我们要通过MediaSource来实现，MediaSource接口功能也很纯粹，作为一个媒体数据容器可以和HTMLMediaElement进行绑定。
基本流程就是通过URL.createObjectURL创建容器的BLob URL，设置到video标签的src上，
在播放过程中，我们仍然可以通过MediaSource.appendBuffer方法往容器里添加数据，达到更新视频内容的目的。