##  开发技巧

### 1. 一个带Icon的非按钮样式的组件

可以使用Button组件，type为link，icon为指定的icon即可

### 2. @import导入less文件

在umi脚手架中，我们需要在一个less文件中导入另外一个less文件，可以这么写：

```js
@import "~@/theme/vars.less";
@import '~antd/lib/style/themes/default.less';
```

less-loader会将所有的非根路径解析成相对路径，例如直接导入如下模块：

```js
@import '@/antd/lib/style/themes/default.less'
// 会报如下的错误
// Can't resolve './@/antd/lib/style/themes/default.less' in 'xxx'
```

所以路径前面要加一个 `~` 符号，表示从模块导入，一般来说从 `node_modules `中导入模块，如直接`@import 'bootstrap'`，当然我们也可以包含alias，从指定路径去导入模块。

### 3. div中大部分元素左对齐，个别元素右对齐

常见的情形：Table上面有搜索条件控件，并排的最右边会放一些操作按钮，这是常见的设计。

可对右对齐的元素使用 `float: right` ，因为还有其他元素在，故不会导致父元素全部坍塌

### 4. 在包含Table的Class组件中定义columns对象

由于columns中有的列可能包含操作，因此要访问组件中的方法，注意this的指向问题。

### 5. umi中如何读取进行了配置的主题变量

从目前看，如下代码，好像是读取的覆盖后的变量值。

```js
@import '~@/antd/lib/style/themes/default.less'
```

### 6. ant design table固定高度

首先要计算所包含容器的高度，使用React的Ref获取到DOM元素，然后获取容器的高度`this.tableRef.current.offsetHeight`，table固定高度有两种方法：

1. 指定scroll属性中的y，但是会有一个问题，因为这个是相当于指定max-height，会根据数据的长度动态变化高度，且当没有数据时会出现Empty组件，table高度也会坍塌，如果不在意可以使用。
2. 指定隐藏的bodyStyle属性，设置高度，但是也有一个问题，Empty组件会被顶到最下面去。

### 7. Flex布局gutter实现

ant design grid组件的实现方式是，每个元素加一个padding-left和padding-right，外层的margin-left，margin-right为负数（相当于扩大了外层容器的宽度）。如下为gutter 16px的例子。

```html
<div class="ant-row" style="margin-left: -8px; margin-right: -8px;">
  <div style="padding-left: 8px; padding-right: 8px;">
    <div class="gutter-box">col-6</div>
  </div>
  <div style="padding-left: 8px; padding-right: 8px;">
    <div class="gutter-box">col-6</div>
  </div>
</div>
```

### 8. 善用Antd的网格布局

```js
import { Row, Col } from 'antd';
```

### 9. Antd4 版本中 ProLayout中路由图标问题

**在使用umi的情况**，umi-plugin-antd-icon-config

由于 pro-layout 支持在 config 中 `icon:string` 的配置，但是在 4.0 中不推荐这样的用法。这个插件可以将其转化，不再引入全量的 icon。 

**在没有使用umi的情况**，参考如下网址[menu icon](https://prolayout.ant.design/menu#%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E8%BD%BD-menu-%E5%B9%B6%E4%B8%94%E4%BD%BF%E7%94%A8-icon)，相当于手动写代码映射到对应的Icon组件

### 10. 哪些在dva，哪些在state中的思考

为避免互相牵连，目前的做法是将page中的所有数据放在model中

### 11. 不要在 render 方法中使用 HOC

React 的 diff 算法（称为协调）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 `render` 返回的组件与前一个渲染中的组件相同（`===`），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。

通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：

```js
render() {
  // 每次调用 render 函数都会创建一个新的 EnhancedComponent
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！
  return <EnhancedComponent />;
}
```

[React官网文档](https://zh-hans.reactjs.org/docs/higher-order-components.html)

### 12. 善用Ref转发

一般我在使用`forwardRef`是在自定义了Form组件，然后需要转发form到自定义组件中的Form组件。注意转发之后的属性不能叫做ref了，通常叫`forwardedRef`

### 13. 中文输入法onChange问题

```js
// 仅处理非输入法情况
  handleInputChange = e => {
    const { onChange } = this.props;
    if (onChange && !this.isComposition) {
      onChange(e.target.value);
    }
  }

  handleCompositionStart = () => {
    this.isComposition = true;
  }

  // 输入法情况由此输入
  handleCompositionEnd = e => {
    this.isComposition = false;
    const { onChange } = this.props;
    if (onChange) {
      onChange(e.target.value);
    }
  }
```

### 14. Flex布局固定宽度（高度）+ 自适应

宽度：其中一个指定宽度500px，另一个指定宽度0，然后flex: 1

高度：同宽度一致

### 15. Antd Button + Modal

若页面中一个button关联一个modal，可以把这个button和这个modal放在一个组件中，这样的抽离方式减少父组件的逻辑。而且modal的显示与否可以由该组件控制。

```jsx
return (
	<>
		<Button>添加用户</Button>
		<Modal>
			xxxx
		</Modal>
	</>
)
```



