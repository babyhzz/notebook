{"./":{"url":"./","title":"Introduction","keywords":"","body":"个人笔记 "},"前端/浏览器/浏览器基础.html":{"url":"前端/浏览器/浏览器基础.html","title":"浏览器基础","keywords":"","body":"浏览器进程 新开一个页面至少会启动如下进程： 浏览器进程 网络进程（NetworkService） GPU进程 渲染进程（隔离，但同一站点公用） 浏览器进程功能 浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 插件进程： 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 每个插件一个，使用才创建。 GPU进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 渲染进程 渲染进程，即Renderer Process，包含如下线程： GUI渲染线程 负责渲染浏览器界面，解析 HTML、CSS构建 DOM 树和 RenderObject 树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。 GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行 JS引擎线程 Javascript 引擎，也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎） JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。 GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理 由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行） 定时器触发线程 传说中的 setInterval 与 setTimeout 所在线程 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行） W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms 异步HTTP请求线程 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行。 "},"前端/浏览器/浏览器缓存.html":{"url":"前端/浏览器/浏览器缓存.html","title":"浏览器缓存","keywords":"","body":"缓存位置 memory cache 存储在内存中的缓存，不受max-age、no-cache的影响，即使不设置缓存，如果内存比较充裕，一些资源也是会被缓存。但是缓存只是暂时的，一旦关闭浏览器，缓存就释放掉，如果这个也不想要，可以设置no-store disk cache 存储在硬盘中的缓存，长时效。 强缓存 强缓存是利用http头中的Expires和Cache-Control来控制。 强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否\"命中\"强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。 Expires: 值为服务器返回的数据到期时间。小于该时间则直接使用缓存。但会存在客户端和服务端时间差问题。这个Http 1.0的产物，一般用Cache-Control代替。 Cache-Control： private：客户端可以缓存 public：客户端和代理服务器都可以缓存 max-age=t：缓存内容将在t秒后失效 no-cache：需要使用协商缓存来验证缓存数据 no-store：所有内容都不会缓存 协商缓存 协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。 Last-Modified/If-Modified-Since: 服务器会返回客户端文件的最后修改时间。客户端再此请求时会带上 If-Modified-Since，没有变更返回304，有变更则返回新的数据。（会存在修改时间虽然改了，但是内容没变的情况。） Etag： 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串可以是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。 Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。 缓存优先级 上述优先级：cache-control > expires > Etag > last-modified "},"前端/浏览器/DOM基础.html":{"url":"前端/浏览器/DOM基础.html","title":"DOM 基础","keywords":"","body":"DOM节点类型 节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。节点类型不同，这三个属性的值也不相同 。其中nodeType可取如下值： 元素节点 　　Node.ELEMENT_NODE(1) 属性节点 　　Node.ATTRIBUTE_NODE(2) 文本节点 　　Node.TEXT_NODE(3) 文档节点 　 Node.DOCUMENT_NODE(9) 注释节点 　 Node.COMMENT_NODE(8) 文档类型节点 　　Node.DOCUMENT_TYPE_NODE(10) // 文档片段节点 　　Node.DOCUMENT_FRAGMENT_NODE(11) // DocumentFragment CDATA节点 Node.CDATA_SECTION_NODE(4) 实体引用名称节点 　　 Node.ENTRY_REFERENCE_NODE(5) 实体名称节点 　　Node.ENTITY_NODE(6) 处理指令节点 　　Node.PROCESSING_INSTRUCTION_NODE(7) DTD声明节点 Node.NOTATION_NODE(12) 其中Node为js内建接口，枚举节点类型。 元素节点 以body为例： nodeType = 1 // Node.ELEMENT_NODE nodeName = 'BODY' nodeValue = null 属性节点 nodeType = 2 // Node.ATTRIBUTE_NODE nodeName = [属性名] nodeValue = [属性值] 文本节点 nodeType = 3 // Node.TEXT_NODE nodeName = '#text' // 注释节点此位置为 \"#comment\" nodeValue = [文本值] node.firstChild 会返回第一个节点类型，而node.firstElementChild则只会选择元素节点返回 文档节点 nodeType = 9 // Node.DOCUMENT_NODE nodeName = '#document' // 注释节点此位置为 \"#comment\" nodeValue = null Document.readyState 当这个属性的值变化时，document对象上的readystatechange事件被触发 loading / 加载 document仍在加载。 interactive / 互动 文档已经完成加载，文档已被解析，但是诸如图像，样式表和框架之类的字资源仍在加载。 complete / 完成 文档和所有子资源已完成加载。状态表示load事件即将被触发。 Document Reload Event log: const log = document.querySelector(\".event-log-contents\"); const reload = document.querySelector(\"#reload\"); reload.addEventListener(\"click\", () => { log.textContent = \"\"; window.setTimeout(() => { window.location.reload(true); }, 200); }); window.addEventListener(\"load\", (event) => { log.textContent = log.textContent + \"load\\n\"; }); document.addEventListener(\"readystatechange\", (event) => { log.textContent = log.textContent + `readystate: ${document.readyState}\\n`; }); document.addEventListener(\"DOMContentLoaded\", (event) => { log.textContent = log.textContent + `DOMContentLoaded\\n`; }); readystate: interactive DOMContentLoaded readystate: complete load DOM高度宽度等属性 偏移量-offset开头的 所有的offset都是以DOM节点的offsetParent进行定位的，和定位上下文有关，及父元素position属性是否为absolute/relative 。 谈谈offsetParent 我们看到上面的定位信息都是基于offsetParent进行定位的，offsetParent具体对应关系如下： 如果当前元素的祖先级元素没有进行CSS定位（position为absolute或relative），offsetParent为body。 如果当前元素的祖先级元素中有CSS定位（position为absolute或relative），offsetParent取最近的那个祖先级元素。 客户区-client开头的 客户区client相对于offset，其widthd和height不包括border边框 滚动大小-scroll开头 window-inner、outer开头 window.innerWidth, window.innerHeight 可视区域的宽高 window.outerWidth, window.outerHeight 整个窗口的宽高，包括导航工具栏以及F12调试面板都在内部 link标签 https://juejin.im/post/5cf517f3f265da1bb13f1c92 最常用是用来链接外部样式表 还可以做其他事情提升页面的性能 DNS Prefetch DNS解析，简单来说就是把域名转化为ip地址。我们在网页里使用域名请求其他资源的时候，都会先被转化为ip地址，再发起链接。dns-prefeth使得转化工作提前进行了，缩短了请求资源的耗时。 什么时候使用呢？当我们页面中使用了其他域名的资源时，比如我们的静态资源都放在cdn上，那么我们可以对cdn的域名进行预解析。浏览器的支持情况也不错。 Preconnect 预链接 我们访问一个站点时，简单来说，都会经过以下的步骤： DNS解析 TCP握手 如果为Https站点，会进行TLS握手 使用preconnect后，浏览器会针对特定的域名，提前初始化链接(执行上述三个步骤)，节省了我们访问第三方资源的耗时。需要注意的是，我们一定要确保preconnect的站点是网页必需的，否则会浪费浏览器、网络资源。 Prefetch 预拉取 link标签里的as参数可以有以下取值： audio: 音频文件 video: 视频文件 Track: 网络视频文本轨道 script: javascript文件 style: css样式文件 font: 字体文件 image: 图片 fetch: XHR、Fetch请求 worker: Web workers embed: 多媒体请求 object: 多媒体请求 document: 网页 预拉取用于标识从当前网站跳转到下一个网站可能需要的资源，以及本网站应该获取的资源。这样可以在将来浏览器请求资源时提供更快的响应。 如果正确使用了预拉取，那么用户在从当前页面前往下一个页面时，可以很快得到响应。但是如果错误地使用了预拉取，那么浏览器就会下载额外不需要的资源，影响页面性能，并且造成网络资源浪费。 这里需要注意的是，使用了prefetch，资源仅仅被提前下载，下载后不会有任何操作，比如解析资源。 Prerender 预渲染 prerender比prefetch更进一步。不仅仅会下载对应的资源，还会对资源进行解析。解析过程中，如果需要其他的资源，可能会直接下载这些资源。这样，用户在从当前页面跳转到目标页面时，浏览器可以更快的响应。 "},"前端/浏览器/页面渲染.html":{"url":"前端/浏览器/页面渲染.html","title":"页面渲染","keywords":"","body":"概念 DOMContentLoaded && Load 在Chrome的Networkd面板里，看到有两个数值和两个竖线，分别是DOMContentLoaded、Load。 DOMContentLoaded需要等界面所有js，css文件解析完成以及html解析完成才会触发。而Load事件会等到图片、视频等资源加载完毕执行。 疑问: 我们为什么一再强调将css放在头部，将js文件放在尾部，这是为什么？ ​ 在面试的过程中，经常会有人在回答页面的优化中提到将js放到body标签底部，原因是因为浏览器生成DOM树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。那么问题来了，既然DOM树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的DOM树，script标签放不放在body底部不是也一样？因为dom树的生成需要整个文档解析完毕。 我们再来看一下打开百度页面，查看Chrome在页面渲染过程中的，绿色标志线是First Paint的时间（红色框框）。为什么会出现firstpaint，页面的paint不是在渲染树生成之后吗？其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。**部分的内容将被解析并显示**。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。 回流(Reflow) 当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。 Reflow 会从 html 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。 常见导致回流的因素 常见的几何属性有 width、height、padding、margin、left、top、border 等等。 获取一些需要通过即时计算得到的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，浏览器为了获取这些值，也会进行回流。 当我们调用了 getComputedStyle 方法，或者 IE 里的 currentStyle 时，也会触发回流。原理是一样的，都为求一个“即时性”和“准确性”。 重绘 当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式。这个过程叫做重绘。 由此我们可以看出，重绘不一定导致回流，回流一定会导致重绘。 Layer层 一共有5个图层：两个滚动条和交叉方块一共三个，header fixed的div占一个图层，内容区域一个图层 栅格化 将图块转换为位图。如图： 渲染流程 渲染流程 按照渲染按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。 渲染进程将 HTML 内容转换为能够读懂DOM 树结构。 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。 创建布局树，并计算元素的布局信息。 对布局树进行分层，并生成分层树。 为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。 "},"前端/浏览器/Chrome调试技巧.html":{"url":"前端/浏览器/Chrome调试技巧.html","title":"Chrome 调试技巧","keywords":"","body":"控制台中的 $0-4/$_ $0-4 最近选择过的5个DOM节点，如$0会返回当前选择的DOM节点 $1 获取控制台上一次输出的结果 页面元素可编辑 document.body.contentEditable = true 代码覆盖率 ctrl + shift + p ，show coverage，点击菜单reload即可显示代码覆盖率 DOM元素的调试 善用Elements中指定DOM右键break on，可以断点DOM元素的改变。DOM元素的Event Listener可以查看该DOM元素的事件，以及会触发祖先节点的事件。 Chrome快捷键 快捷键 作用 Ctrl + L 清空控制台 有用的控制台命令 命令 用途 console.table 以table的形式展示对象 console.count 计算方法执行的次数 copy 将内容复制到剪切板 keys/values 同Object.keys/Object.values，返回对象的key和values console.time/console.timeEnd 配合一起记录时间 // console.count function func(){console.count(\"这个方法执行的次数\");} // func() // VM905:1 这个方法执行的次数: 1 "},"前端/浏览器/EventLoop.html":{"url":"前端/浏览器/EventLoop.html","title":"Event Loop","keywords":"","body":"微任务宏任务 宏任务：可以认为每次执行栈（call stack）中执行的代码是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中），宏任务和渲染是交叉进行，渲染线程会将宏任务对DOM的修改做优化。 注意setTimeout的回调属于下一次宏任务。 包括script代码、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、RequestAnimationFrame等 微任务：宏任务之后，渲染之前，会将期间产生的所有微任务都执行。Promise中的then触发时（即Resolve时），将会插入微任务队列。如Promise.then、MutationObserver、process.nextTick（Node.js环境） 所以执行流程是：宏任务 -> 微任务 -> 渲染 -> 宏任务 -> 微任务 -> 渲染 -> ... js是单线程的，若是多线程不加锁，会导致渲染结果不可预期 GUI渲染线程与JS引擎互斥（若一边修改一边渲染会导致渲染结果不一致），渲染线程会在JS引擎空闲时执行 EventLoop概念 JS 分为同步任务和异步任务，同步任务都在JS线程上执行，形成一个执行栈，JS线程只执行执行栈中的任务。 事件触发线程管理一个事件队列，异步任务触发条件达成，会将回调事件放到事件队列中 执行栈中的代码执行完毕，就会读取事件队列中的事件，添加到执行栈中，开始执行 Event Table 可以理解成一张事件->回调函数 对应表，Event Queue 简单理解就是回调函数队列，所以它也叫Callback Queue EventLoop原理 在前端开发中我们会通过setTimeout/setInterval来指定定时任务，会通过XHR/fetch发送网络请求， 接下来简述一下setTimeout/setInterval和XHR/fetch到底做了什么事 我们知道，不管是setTimeout/setInterval和XHR/fetch代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。 当代码执行到setTimeout/setInterval时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而定时触发器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由事件触发线程所管理的事件队列中。 当代码执行到XHR/fetch时，实际上是JS引擎线程通知异步http请求线程，发送一个网络请求，并指定请求完成后的回调事件， 而异步http请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由事件触发线程所管理的事件队列中。 当我们的同步任务执行完，JS引擎线程会询问事件触发线程，在事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给JS引擎线程执行 "},"前端/React/React基础.html":{"url":"前端/React/React基础.html","title":"React 基础","keywords":"","body":"生命周期 你真的了解 React 生命周期吗 官网生命周期 constructor(props) 应在其他语句之前调用super(props)，不然this.props在构造函数中会出现未定义。可以在constructor中定义state以及函数的bind，我比较喜欢使用Class Fields语法来实现，需要babel支持。 componentDidMount() 会在组件挂载后调用（插入到DOM数中），一般在这里进行数据获取然后调用setState赋值。如果有一些依赖DOM节点的大小和位置，可在这里处理。如Ant Design中Table的高度获取。 componentDidUpdate(prevProps, prevState, snapshot) 当组件更新后立即执行，首次渲染不会执行。 当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。 componentDidUpdate(prevProps) { // 典型用法（不要忘记比较 props）： if (this.props.userID !== prevProps.userID) { this.fetchData(this.props.userID); } } 你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。如果实现了 getSnapshotBeforeUpdate()生命周期函数，将作为第三个参数传入。 componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。 static getDerivedStateFromProps(props, state) 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 返回一个对象来更新state，null则表示不更新。静态函数，无法访问组件内部方法。 getDerivedStateFromProps 的存在只有一个目的：让组件在 props 变化时更新 state。比如根据props变化加载外部数据。 shouldComponentUpdate(nextProps, nextState) 判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。首次渲染或使用 forceUpdate() 时不会调用该方法。 我们不建议在 shouldComponentUpdate() 中进行深层比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能。 官网意思是，不要过分依赖这个，后续可能改变这个功能，尽量使用PureComponent。 getSnapshotBeforeUpdate(prevProps, prevState) 接收父组件传递过来的 props 和组件之前的状态，此生命周期钩子必须有返回值，返回值将作为第三个参数传递给 componentDidUpdate。必须和 componentDidUpdate 一起使用，否则会报错。作用：能让你在组件更新DOM和refs之前，从DOM中捕获一些信息（如滚动位置） 触发时机：组件Update时，在render之后，更新DOM和refs之前。 父子组件生命周期 mount阶段 Parent getDerivedStateFromProps Parent render Child getDerivedStateFromProps Child render Child componentDidMount Parent componentDidMount 可见在render时，先render父组件，然后在render子组件。didmount回调，则先触发子组件mount，再触发父组件mount。 update阶段（parent组件state变化） Parent getDerivedStateFromProps Parent render Child getDerivedStateFromProps Child shouldComponentUpdate Child render Child componentDidUpdate Parent componentDidUpdate 可见父组件update时，先出发父组件的render，然后是子组件的render，didupdate回调，子组件先出发，父组件后触发 unmount阶段 先出发父组件unmount，然后触发子组件unmount 常见问题 当外部的 props 改变时，如何再次执行请求数据、更改状态等操作 componentDidUpdate 中发数据请求，注意if判断 组件绑定一个key属性，当key变化时，会卸载原来组件重新创建组件。 如果setState更新的值不变，还会触发生命周期钩子吗？ 哪怕每次都设置同样的值，还是会触发更新 props变化时重置内部state key属性，key变化时会创建一个新的组件而不是更新一个既有的组件，会重置所有内部state 使用getDerivedStateFromProps，比较前后props变化，可重置部分状态 ref方式调用内部方法，但是这个通常不建议 缓存基于当前 props 计算后的结果 实用，特别是在列表过滤。使用memoize-one技术，仅缓存最近一次的结果，因为组件会碰到经常render的情况，而render中根据属性计算结果。使用缓存技术，可以保证相关的参数没有改变，不必重新计算，直接使用缓存。 条件渲染 可使用 && 运算符，react 对与false，true，null都渲染为空 PureComponent PureComponent实现了shouldComponentUpdate，对于props和state的浅比较，对于函数式组件的React.memo（Hook中的memo如何运作？） 组合函数 const name = compose( splitmyName, countEachName, comvertUpperCase, returnName ) // compose简单的实现方式： const compose = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args))); 组件类型 展示组件：无状态，纯函数，没有任何副作用。 容器组件：获取处理数据、订阅Redux存储的组件，可包含展示组件和其他容器组件。 Render Props 具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑。 render prop 是一个用于告知组件需要渲染什么内容的函数 prop。 任何被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”。 children也可以是函数，作为Render Props。比如可以实现一个vue slot的应用场景，如果没有children则按照默认渲染，若有则按照children规定方式渲染 高阶组件HOC HOC可以干什么 组合渲染 条件渲染 操作props 获取ref 状态管理，如可以把Input的value放在HOC中 操作State，只能在反向继承中实现 渲染劫持，只要改变了原组件的渲染，我们都将它称之为一种渲染劫持 compose 和 Decorators 假设现在我们有logger，visible，style等多个HOC，现在要同时增强一个Input组件。 // 第一种，难以阅读 logger(visible(style(Input))) // 第二种，提供一个compose函数，与第一种类似 const compose = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args))); compose(logger,visible,style)(Input); // 第三种 @logger @visible @style class Input extends Component { // ... } React Hooks 30分钟精通React Hooks 【React深入】从Mixin到HOC再到Hook React Hooks 详解 【近 1W 字】+ 项目实战 官网：使用 Effect Hook（很详细） HOOK FAQ 可以多领会 为什么要搞一个Hooks 复用一个有状态的组件太麻烦，官方解决方案：Render Props 和 HOC（提供获取信息功能）。 生命周期钩子函数逻辑乱，比如异步数据请求，有时我们需要在componentDidMount和componentDidUpdate中做同样的事情。 class this指向问题 useState const [count, setCount] = useState(0); useState初始状态可以是一个函数，只在初始渲染时调用 setCount可以使用函数式更新，参数为先前的state useEffect 之前class组件，对于一些副作用，我们会写在 componentDidMount/componentDidUpdate/componentWillUnmount 中，但是现在使用一个 useEffect 即可，三合一！ 要点： React首次渲染和以后的每次渲染都会调用传给useEffect的函数，而之前需要在componentDidMount和componentDidUpdate中分别实现。 useEffect中的函数是异步执行的，不会阻塞浏览器更新视图。而之前的componentDidMount和componentDidUpdate都是同步的（当然是可以加async/await处理异步任务的）。 useEffect清除副作用，返回一个函数即可。它会在调用一个新的 effect 之前对前一个 effect 进行清理。注意前一个effect的清理函数保持着之前的状态。 useEffect的第二个参数，可以条件执行effect，只要值没有发送变化则不用执行effect，注意hook是利用Object.is进行浅比较。若传一个空数组， 则表示只运行一次的 effect（仅在组件挂载和卸载时执行） 每次渲染都有自己独立的props和state 可以使用多个Effect关注分离点，也就是说可以写多个useEffect，功能不一样的可以分离 useEffect 在全部渲染完毕后才会执行，而useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行 执行时机：useEffect 会在第一次渲染之后和每次更新之后都会执行 // Mount with { friend: { id: 100 } } props ChatAPI.subscribeToFriendStatus(100, handleStatusChange); // 运行第一个 effect // Update with { friend: { id: 200 } } props ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // 清除上一个 effect ChatAPI.subscribeToFriendStatus(200, handleStatusChange); // 运行下一个 effect // Update with { friend: { id: 300 } } props ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // 清除上一个 effect ChatAPI.subscribeToFriendStatus(300, handleStatusChange); // 运行下一个 effect // Unmount ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // 清除最后一个 effect 其他Hooks useContext const value = useContext(MyContext); 当组件上层最近的 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。 useLayoutEffect 它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 useEffect是异步执行的，会在合适的时机渲染，而useLayoutEffect是在浏览器绘制之前执行，会阻塞渲染。 经典的例子，地址这里： import React, { useEffect, useState, useLayoutEffect, useRef } from 'react'; import { render } from 'react-dom'; function App() { const [count, setCount] = useState(0); // 换成useLayoutEffect查看 useEffect(() => { if (count === 0) { const randomNum = 10 + Math.random()*200 setCount(10 + Math.random()*200); } }, [count]); return ( <> {count} setCount(0)}>点击 ); } render(, document.getElementById('root')); 当点击div的时候，页面会更新一串随机数。当你连续点击时，你会发现这串数字在发生抖动。原因在于，当你每次点击div，count会更新为0，之后useEffect内又把count改为一串随机数。所以页面会先渲染成0，然后再渲染成随机数，由于更新很快，所以出现了闪烁。 将 useEffect 改为 useLayoutEffect：相比使用useEffect，当你点击 div，count更新为0，此时页面并不会渲染，而是等待 useLayoutEffect 内部状态修改后，才会去更新页面，所以页面不会闪烁。 因此useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。 useCallback memoized回调函数，当作为属性传递给子组件时，子组件若使用引用相等去优化时很有用 const memoizedCallback = useCallback( () => { doSomething(a, b); }, [a, b], ); useMemo 仅在依赖发生改变时触发 const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]); 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。 类似于memoize-one，避免每次都进行高开销的计算，useMemo仅在依赖项改变时，才重新计算。 useRef 传入的初始值为refContainer的current属性的初始值 const refContainer = useRef(initialValue); useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。 function FancyInput(props, ref) { const inputRef = useRef(); useImperativeHandle(ref, () => ({ focus: () => { inputRef.current.focus(); } })); return ; } FancyInput = forwardRef(FancyInput); 自定义Hook 把相同的Hook逻辑提取到一个自定义Hook中 import React, { useState, useEffect } from 'react'; // 参数为某个好友的ID，如果friendID变化，则会触发Hook中的副作用。 function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() => { // 注意这个函数写在了内部 function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () => { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } 要点： 自定义Hook以use开头. 使用相同Hook中的state不会被共享 必须把hooks写在函数最外面，不允许在if/else等条件语句中，保证hooks的执行顺序一致. HOOK FAQ 该如何测量 DOM 节点？ 获取 DOM 节点的位置或是大小的基本方式是使用 callback ref。每当 ref 被附加到一个另一个节点，React 就会调用 callback。 在这个案例中，我们没有选择使用 useRef，因为当 ref 是一个对象时它并不会把当前 ref 的值的 变化 通知到我们。使用 callback ref 可以确保 即便子组件延迟显示被测量的节点 (比如为了响应一次点击)，我们依然能够在父组件接收到相关的信息，以便更新测量结果。 注意到我们传递了 [] 作为 useCallback 的依赖列表。这确保了 ref callback 不会在再次渲染时改变，因此 React 不会在非必要的时候调用它。 定义在useEffect中的函数 尽量将useEffect调用函数写在useEffect内部，可以更清晰的发现依赖变量。 如何实现shouldComponentUpdate 使用React.memo来包裹一个函数式组件。 如何惰性创建昂贵对象 useMemo允许记住一次昂贵的计算。 state初始值的函数式方式加载。 "},"前端/React/React最佳实践.html":{"url":"前端/React/React最佳实践.html","title":"React 最佳实践","keywords":"","body":"React最佳实践 1. 多用 Function Component 如果组件是纯展示型的，不需要维护 state 和生命周期，则优先使用 Function Component。代码更简洁，更好的复用性，更小的打包体积，更高的执行效率。 2. 多用 PureComponent 如果组件需要维护 state 或使用生命周期方法，则优先使用 PureComponent，而不是 Component。 Component 的默认行为是（调用 this.setState 时）不论 state 和 props 是否有变化，都触发 render。而 PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render。 3. 遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责 比如一个公用的组件，数据来源可能是父组件传过来，又或者是自己主动通过网络请求获取数据。这时候可以先定义一个纯展示型的 Function Component，然后再定义一个高阶组件去获取数据 4. 避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render 如下例子，即使Child是PureComponent，不会有任何优化效果，因为obj每次都是新的。 render() { const obj = { num: 1 } return ( // onClick每次都是新对象？ {... }} /> ); } 5. 多使用解构，如 Function Component 的 props const MenuItem = ({ menuId, menuText, onClick, activeId, }) => { return ( ... ); }; 6. 定义组件时，定义 PropTypes 和 defaultProps class CategorySelector extends PureComponent { ... } CategorySelector.propTypes = { type: PropTypes.string, catList: PropTypes.array.isRequired, default: PropTypes.bool, }; CategorySelector.defaultProps = { default: false, type: undefined, }; 7. 避免使用无谓的标签和样式 // bad // good "},"前端/React/React虚拟DOM.html":{"url":"前端/React/React虚拟DOM.html","title":"React 虚拟 DOM","keywords":"","body":"React虚拟DOM 页面呈现的三个阶段 JS 计算 (Scripting) 生成渲染树 (Rendering) 绘制页面 (Painting) Virtual DOM很快前提 javascript很快 DOM很慢，DOM对象很复杂，创建和更新都比较耗时 虚拟DOM简单步骤 用JavaScript对象来表示DOM树的结构； 然后用这个树构建一个真正的DOM树，插入到文档中。 当状态变更的时候，重新构造一个新的对象树，然后用这个新的树和旧的树作对比，记录两个树的差异。 把2所记录的差异应用在步骤1所构建的真正的DOM树上（生成patch），视图就更新了。 "},"前端/React/React事件机制.html":{"url":"前端/React/React事件机制.html","title":"React 事件机制","keywords":"","body":"概念 React 的所有事件并没有绑定到具体的dom节点上而是绑定在了document 上，然后由统一的事件处理程序来处理，同时也是基于浏览器的事件机制（冒泡），所有节点的事件都会在 document 上触发 由于原生事件先于合成事件，所以原生事件阻止冒泡肯定会阻止合成事件的触发，但合成事件的阻止冒泡不会影响原生事件。 react合成事件做的事情： 对原生事件的封装，e.nativeEvent表示原生事件 对某些事件的升级和改造，如onChange事件，原生只会在失去焦点时触发，React会注册很多其他的事件上去 不同浏览器事件兼容处理，如IE的AttachEvent SyntheticEvent是react合成事件的基类，定义了合成事件的基础公共属性和方法。 react会根据当前的事件类型来使用不同的合成事件对象，比如鼠标单机事件 - SyntheticMouseEvent，焦点事件-SyntheticFocusEvent等，但是都是继承自SyntheticEvent。 事件注册到listenerBank中，这是一个二级map，第一级是事件名称，第二级是key EventPluginHub 参考 https://www.cnblogs.com/pingan8787/p/11838083.html "},"前端/React/开发实战.html":{"url":"前端/React/开发实战.html","title":"开发实战","keywords":"","body":"开发技巧 1. 一个带Icon的非按钮样式的组件 可以使用Button组件，type为link，icon为指定的icon即可 2. @import导入less文件 在umi脚手架中，我们需要在一个less文件中导入另外一个less文件，可以这么写： @import \"~@/theme/vars.less\"; @import '~antd/lib/style/themes/default.less'; less-loader会将所有的非根路径解析成相对路径，例如直接导入如下模块： @import '@/antd/lib/style/themes/default.less' // 会报如下的错误 // Can't resolve './@/antd/lib/style/themes/default.less' in 'xxx' 所以路径前面要加一个 ~ 符号，表示从模块导入，一般来说从 node_modules中导入模块，如直接@import 'bootstrap'，当然我们也可以包含alias，从指定路径去导入模块。 3. div中大部分元素左对齐，个别元素右对齐 常见的情形：Table上面有搜索条件控件，并排的最右边会放一些操作按钮，这是常见的设计。 可对右对齐的元素使用 float: right ，因为还有其他元素在，故不会导致父元素全部坍塌 4. 在包含Table的Class组件中定义columns对象 由于Table中的列有的可能会操作数据，因此可以将columns定义为class的成员变量，这样可以访问内部方法 5. umi中如何读取进行了配置的主题变量 从目前看，如下代码，好像是读取的覆盖后的变量值。 @import '~@/antd/lib/style/themes/default.less' 6. ant design table固定高度 首先要计算所包含容器的高度，使用React的Ref获取到DOM元素，然后获取容器的高度this.tableRef.current.offsetHeight，table固定高度有两种方法： 指定scroll属性中的y，但是会有一个问题，因为这个是相当于指定max-height，会根据数据的长度动态变化高度，且当没有数据时会出现Empty组件，table高度也会坍塌，如果不在意可以使用。 指定隐藏的bodyStyle属性，设置高度，但是也有一个问题，Empty组件会被顶到最下面去。 若需要分页需要根据容器大小动态计算pageSize，有两种情况： 若容器div非动态呈现，直接通过dom引用获取高度 若容器div动态呈现，如Modal或Drawer类似组件，内部容器mount阶段，若高度有flex等自适应样式，其高度获取将会为0，因为需要进行渲染生成高度信息，故table容器div高度需要经过渲染后获取，故采用setTimeout 让其在下一次宏任务中获取 7. Flex布局gutter实现 ant design grid组件的实现方式是，每个元素加一个padding-left和padding-right，外层的margin-left，margin-right为负数（相当于扩大了外层容器的宽度）。如下为gutter 16px的例子，左右padding为8px。 个人理解：1. 这里内部容器为什么要用padding而不用margin？是不是因为存在margin合并的问题？2. 去除内部容器作用两边的padding使用的是负margin，这样实现了内容区域扩大。3. 这里的计算方式，是不是说明gutter最好是偶数？ col-6 col-6 Antd4 版本中 ProLayout中路由图标问题 在使用umi的情况，umi-plugin-antd-icon-config 由于 pro-layout 支持在 config 中 icon:string 的配置，但是在 4.0 中不推荐这样的用法。这个插件可以将其转化，不再引入全量的 icon。 在没有使用umi的情况，参考如下网址menu icon，相当于手动写代码映射到对应的Icon组件 不要在 render 方法中使用 HOC React 的 diff 算法（称为协调）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。 通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC： render() { // 每次调用 render 函数都会创建一个新的 EnhancedComponent // EnhancedComponent1 !== EnhancedComponent2 const EnhancedComponent = enhance(MyComponent); // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！ return ; } React官网文档 12. 善用Ref转发 forwardRef将ref转发到组件内部某个子组件，为什么要使用转发呢？因为ref属性是react的关键字，指向组件实例（函数式组件没有实例对象），无法进行传递。React.forwardRef可以看作是一个特殊的组件，能获取ref对象。 const FancyButton = React.forwardRef((props, ref) => ( {props.children} )); function logProps(Component) { class LogProps extends React.Component { componentDidUpdate(prevProps) { console.log('old props:', prevProps); console.log('new props:', this.props); } render() { const {forwardedRef, ...rest} = this.props; // 将自定义的 prop 属性 “forwardedRef” 定义为 ref return ; } } // 注意 React.forwardRef 回调的第二个参数 “ref”。 // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef” // 然后它就可以被挂载到被 LogProps 包裹的子组件上。 // 注意此处ref必须转换成常规属性！！！！！！！！！！ return React.forwardRef((props, ref) => { return ; }); } 13. 中文输入法onChange问题 // 仅处理非输入法情况 handleInputChange = e => { const { onChange } = this.props; if (onChange && !this.isComposition) { onChange(e.target.value); } } handleCompositionStart = () => { this.isComposition = true; } // 输入法情况由此输入 handleCompositionEnd = e => { this.isComposition = false; const { onChange } = this.props; if (onChange) { onChange(e.target.value); } } 14. Flex布局固定宽度（高度）+ 自适应 宽度：其中一个指定宽度500px，另一个指定宽度0，然后flex: 1 高度：同宽度一致 Q: flex: 1时为啥要指定width: 0呢？ 若没有指定width，当内容区域大于平均分配的剩余控件，则宽度取内容大小。若指定了width（多个也是一样），并且小于平均分配的剩余空间（不一定非要为0，小于即可），则取平均分配的剩余空间。若其中一个width大于平均分配剩余空间，则会压缩另外一个flex：1的剩余空间，但不能比其width还小，当无法压缩时，会将父容器撑开。 Document .container { width: 200px; height: 200px; display: flex; } .fixed { width: 50px; background-color: rebeccapurple; } .flex { width: 150px; background-color: red; flex: 1; } aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb 15. Antd Button + Modal 若页面中一个button关联一个modal，可以把这个button和这个modal放在一个组件中，这样的抽离方式减少父组件的逻辑。而且modal的显示与否可以由该组件控制。 return ( <> 添加用户 xxxx ) 16. 多用defaultProps为组件指定默认属性，而不是用es6的参数默认值 class A extends Component { static defaultProps = { // ... 默认值指定 } } "},"前端/JS/手写代码.html":{"url":"前端/JS/手写代码.html","title":"手写代码","keywords":"","body":"参考 https://www.cnblogs.com/chenwenhao/p/11294541.html 1. 手写 new 操作符 function createNew() { let obj = {}; // 下面写法会修改arguments，引起副作用 // const ctor = Array.prototype.shift.call(arguments); const [ctor, ...args] = arguments; obj.__proto__ = ctor.prototype; // const result = ctor.apply(obj, arguments); const result = ctor.apply(obj, args); return typeof result === 'object' ? result : obj; } 2. 手写 object.create // 实现 object.create() function create(obj) { function F() { } F.prototype = obj; return new F(); } 3. 手写 call Function.prototype.myCall = function () { if (typeof this !== 'function') { throw new TypeError('not funciton'); } // 创建一个谁调用指向谁的环境 const ctx = arguments[0] || window; ctx.fn = this; // arguments 为一个类数组，并非一个真的数组 const args = [...arguments].slice(1); const result = ctx.fn(...args); delete ctx.fn; return result; } 4. 手写 apply Function.prototype.myApply = function () { if (typeof this !== 'function') { throw new TypeError('not funciton'); } const ctx = arguments[0] || window; ctx.fn = this; let result; if (arguments[1]) { result = ctx.fn(...arguments[1]) } else { result = ctx.fn(); } delete ctx.fn; return result; } 5. 实现bind Function.prototype.bind = function () { if (typeof this !== 'function') { throw new TypeError('not funciton'); } const fToBind = this; const ctx = arguments[0]; const args = [...arguments].slice(1); function F() { // 函数使用 new 的情况??? if (this instanceof F) { return new self(...args, ...arguments); } else { return fToBind.apply(ctx, args.concat(...arguments)) } } F.prototype = fToBind.prototype; return F; } 5. 浅拷贝、深拷贝 浅拷贝可使用扩展运算符和Object.assign 简单对象的深拷贝可以使用 JSON.parse(JSON.stringify(obj)) 方式 缺点：无法很好处理拷贝对象包含 正则表达式，函数，或者undefined等值，undefined的值会自动删除 6. 实现一个节流、防抖函数 // 节流，在规定时间只触发一次 function throttle(fn, delay) { let prev = Date.now(); return function() { let cur = Date.now(); if (cur - prev > delay) { fn.apply(this, arguments); prev = Date.now(); } } } // 防抖，在规定时间没有触发第二次则执行 function debounce(fn, delay) { let timer = null; return function () { const args = arguments; const self = this; clearTimeout(timer); timer = setTimeout(function() { fn.apply(self, args) }, delay); } } 7. instanceof 原理 // instanceof function instanceOf(obj, func) { let proto = obj.__proto__; if (proto === null) { return false; } while(proto !== null) { if (proto === func.prototype) { return true; } proto = proto.__proto__; } return false; } 8. 实现reducer，map，filter // 实现 map Array.prototype.myMap = function (fn) { const arr = [...this]; const mappedArr = []; for (let i = 0; i inc + value); console.log(result); // 实现一个 filter Array.prototype.myFilter = function (fn, context) { const arr = [...this]; let filterArr = []; for (let i = 0; i val % 2 === 0)); 9. 实现一个基本的EventBus 下面是一个简单的实现，待改进 如何取消一个listener？ class EventEmitter { constructor() { this.listeners = {}; } on(type, fn) { console.log(this.listeners); if (this.listeners[type]) { this.listeners[type].push(fn); } else { this.listeners[type] = [fn]; } } emit(type, ...args) { const listeners = this.listeners[type]; if (listeners) { listeners.forEach((fn) => { fn.apply(this, args); }); } } } var emitter = new EventEmitter(); emitter.on(\"console\", function (a) { console.log(a); }); emitter.emit(\"console\", 1); 10. 手写排序（冒泡，选择，插入，快排） 冒泡排序 // 从前往后冒泡，每次冒泡都冒泡一个zui'da function bubbleSort(arr) { // 待冒泡的元素个数 let n = arr.length; while (n > 1) { for (let i = 1; i arr[i]) { let temp = arr[i - 1]; arr[i - 1] = arr[i]; arr[i] = temp; } } n -= 1; } } var arr1 = [23, 1, 4, 3, 4, 77, 99, 5, 6, 3434, 3333]; bubbleSort(arr1); console.log(arr1); 选择排序 // 每次从剩下元素中选出最小元素 function selectSort(arr) { // 异常判断 if (!Array.isArray(arr)) { throw new TypeError(\"not array\"); } const len = arr.length; for (let m = 0; m 快速排序 function quickSort(arr, beginIndex, endIndex) { if (beginIndex >= endIndex) { return; } let temp = arr[beginIndex]; let low = beginIndex; let high = endIndex; while (low = temp) { high--; } while (low 11. 简易版Promise const PENDING = 'PENDING'; const RESOLVED = 'RESOLVED'; const REJECTED = 'REJECTED'; class PromiseA { // executor 为参数 (resolve, reject) => {} 的回调函数 constructor(executor) { this.executor = executor; this.status = PENDING; this.value = undefined; this.reason = undefined; this.resolvedCallbacks = []; this.rejectedCallbacks = []; const resolve = value => { if (this.status === PENDING) { this.status = RESOLVED; this.value = value; this.resolvedCallbacks.forEach(fn => fn(value)); } } const reject = reason => { if (this.status === PENDING) { this.status = REJECTED; this.reason = reason; this.rejectedCallbacks.forEach() } } executor(resolve, reject); } then(onFulfilled, onRejected) { if (this.status === RESOLVED) { onFulfilled(this.value); } if (this.status === REJECTED) { onRejected(this.value); } if (this.status === PENDING) { this.resolvedCallbacks.push(onFulfilled); this.rejectedCallbacks.push(onRejected); } } } // test var a = new PromiseA((resolve, reject) => { setTimeout(() => resolve('11111111111'), 3000); }); a.then(value => console.log('resolve 22222 => ', value)); a.then(value => console.log('resolve 33333 => ', value)); "},"前端/CSS/CSS基础.html":{"url":"前端/CSS/CSS基础.html","title":"CSS 基础","keywords":"","body":"常用技巧 清除浮动(antd版) .clearfix { zoom: 1; } .clearfix::before, .clearfix::after { display: table; content: ''; } .clearfix::after { clear: both; } 包裹的两个元素左右分开 可以使用如下样式： display: flex; justify-content: space-between; 布局 两行布局，上面固定，下面占满 头部DIV 下部DIV 方案一 外层padding，内层absolute html, body { height: 100%; padding: 0; margin: 0; } .outer { height: 100%; padding: 100px 0 0; box-sizing: border-box ; position: relative; } .A { height: 100px; background: #BBE8F2; position: absolute; top: 0 ; left: 0 ; width: 100%; } .B { height: 100%; background: #D9C666; } 方案二 负margin html, body { height: 100%; padding: 0; margin: 0; } .outer { height: 100%; padding: 100px 0 0; box-sizing: border-box ; } .A { height: 100px; margin: -100px 0 0; background: #BBE8F2; } .B { height: 100%; background: #D9C666; } 方案三 flex html, body { height: 100%; padding: 0; margin: 0; } .outer { height: 100%; display: flex; flex-direction: column; box-sizing: border-box ; } .A { height: 100px; background: #BBE8F2; } .B { flex: 1 0 0; background: #D9C666; overflow-y: auto } 伪元素 float float 设计出来的初衷是实现文字环绕效果 具有如下特性： 破坏性，脱离文档流，会导致父元素坍塌 包裹性，会包裹内容，可以设置宽高，将按照设定的宽高进行包裹 清空格，根本原因是由于 float 会导致节点脱离文档流结构，它身边的什么换行、空格就都和它没关系的 清除浮动 float 具有“破坏性”，它会导致父元素“坍塌”，这将不是所要看到的。 两个比较简单，但是不常用的解决方法： 为父元素添加 overflow:hidden 浮动父元素 所有浮动元素下方添加一个 clear:both 的元素（style=\"clear:both\"） clearfix（BootStrap 使用的方案） .clearfix:after { content: \"\"; display: table; clear: both; } float 三列布局 中间的 div 宽度还是整个宽度，但不会覆盖左右浮动部分 float 两列布局 左侧 float，固定 width，右侧 div 设置 margin-left 即可 参考 https://www.cnblogs.com/wangfupeng1988/p/4314160.html https://www.cnblogs.com/wangfupeng1988/p/4314804.html position定位属性 position 一共有四个可选属性：static/relative/absolute/fixed。其中 static（静态定位）是默认值，即所有的元素如果不设置其他的 position 值，它的 position 值就是 static，有它跟没有它一样。 relative relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小的变化。 relative 产生一个新的定位上下文 absolute 脱离文档流，产生破坏性，导致父元素坍塌。 包裹性 悬浮在页面上方，会遮挡住下方的页面内容 fixed fixed 和 absolute 是一样的，唯一的区别在于：absolute 元素是根据最近的定位上下文确定位置，而 fixed 永远根据浏览器确定位置。 定位上下文 relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。 fixed 元素的定位永远是相对于浏览器边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。 absolute 的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了 position:relative/absolute/fixed 的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示： 参考 https://www.cnblogs.com/wangfupeng1988/p/4322680.html "},"前端/CSS/Flex.html":{"url":"前端/CSS/Flex.html","title":"Flex","keywords":"","body":"Flex 1. flex-basis 和 width关系 经常在项目中碰到左侧宽度固定，右侧自适应清空，使用flex-basis: 0 0 100px，想的是可以固定宽度，发现有时无法固定宽度，原因是：在width为auto的情况下，当实际宽度 > flex-basis的情况下，以实际宽度为准 默认值 flex-basis 默认值：auto，即flex-basis的属性值为项目的width属性值 width 默认值：auto，即项目的width属性值为项目内容的宽度 项目的实际宽度是flex-basis与width比较求得 flex实际宽度 width为auto 实际内容宽度 > flex-basis，则宽度为实际内容宽度 实际内容宽度 总结就是以尺寸大的为准 width不为auto + 不设置overflow: hidden 会按width、内容宽度、flex-basis计算得到，一般不会都指定 over-flow: hidden 无论任何情况，都以flex-basis为准（亲测是的，width不起作用） "},"前端/CSS/BFC.html":{"url":"前端/CSS/BFC.html","title":"BFC","keywords":"","body":"概念 Block Formatting Context (块级格式化上下文)，具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 如何触发BFC 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 特性及应用 1. 同一BFC下margin会发生折叠 Document div { width: 100px; height: 100px; background: lightblue; margin: 100px; } 如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 2. BFC 可以包含浮动的元素（清除浮动） 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果触发容器的 BFC，那么容器将会包裹着浮动元素。 3. BFC 可以阻止元素被浮动元素覆盖 我是一个左浮动的元素 我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee; 这时候第二个元素有部分被浮动元素所覆盖（但是文本信息不会被浮动元素所覆盖），如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成： 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。 "},"前端/webpack/webpack.html":{"url":"前端/webpack/webpack.html","title":"webpack","keywords":"","body":"webpack 中比较难懂的几个变量名称 1. module，chunk 和 bundle 的区别是什么？ 看这个图就很明白了： 对于一份同逻辑的代码，当我们手写了一个个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 module； 当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作； webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。 一般来说一个 chunk 对应一个 bundle，比如上图中的 utils.js -> chunks 1 -> utils.bundle.js；但也有例外，比如说上图中，我就用 MiniCssExtractPlugin 从 chunks 0 中抽离出了 index.bundle.css 文件。 一句话总结： module，chunk 和 bundle 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。 2.filename 和 chunkFilename 的区别 filename filename 是一个很常见的配置，就是对应于 entry 里面的输入文件，经过webpack 打包后输出文件的文件名。 const path = require('path'); module.exports = { entry: './path/to/my/entry/file.js', output: { path: path.resolve(__dirname, 'dist'), filename: '[name].bundle.js' } }; chunkFilename chunkFilename 指未被列在 entry 中，却又需要被打包出来的 chunk 文件的名称。一般来说，这个 chunk 文件指的就是要懒加载的代码。 output.chunkFilename 默认使用 [id].js 或从 output.filename 中推断出的值（[name] 会被预先替换为 [id] 或 [id].） 一句话总结： filename 指列在 entry 中，打包后输出的文件的名称。 chunkFilename 指未列在 entry 中，却又需要被打包出来的文件的名称。 3.webpackPrefetch、webpackPreload 和 webpackChunkName 到底是干什么的？ webpackChunkName 前面举了个异步加载 lodash 的例子，我们最后把 output.chunkFilename 写死成 bundle.js。在我们的业务代码中，不可能只异步加载一个文件，所以写死肯定是不行的，但是写成 [name].bundle.js 时，打包的文件又是意义不明、辨识度不高的 chunk id。 这时候 webpackChunkName 就可以派上用场了。我们可以在 import 文件时，在 import 里以注释的形式为 chunk 文件取别名： async function getAsyncComponent() { var element = document.createElement('div'); // 在 import 的括号里 加注释 /* webpackChunkName: \"lodash\" */ ，为引入的文件取别名 const { default: _ } = await import(/* webpackChunkName: \"lodash\" */ 'lodash'); element.innerHTML = _.join(['Hello!', 'dynamic', 'imports', 'async'], ' '); return element; } 但生成的打包文件名是 vendors~lodash.bundle.js，前面多出来一个 vendors~。其实 webpack 懒加载是用内置的一个插件 SplitChunksPlugin 实现的，这个插件里面有些默认配置项，比如说 automaticNameDelimiter，默认的分割符就是 ~，所以最后的文件名才会出现这个符号，这块儿内容我就不引申了，感兴趣的同学可以自己研究一下。 webpackPrefetch 和 webpackPreload 这两个配置一个叫预拉取（Prefetch），一个叫预加载（Preload），两者有些细微的不同，我们先说说 webpackPrefetch。 在上面的懒加载代码里，我们是点击按钮时，才会触发异步加载 lodash 的动作，这时候会动态的生成一个 script 标签，加载到 head 头里： 如果我们 import 的时候添加 webpackPrefetch： const { default: _ } = await import(/* webpackChunkName: \"lodash\" */ /* webpackPrefetch: true */ 'lodash'); 就会以 的形式预拉取 lodash 代码： 这个异步加载的代码不需要手动点击 button 触发，webpack 会在父 chunk 完成加载后，闲时加载 lodash 文件。 webpackPreload 是预加载当前导航下可能需要资源，他和 webpackPrefetch 的主要区别是： preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。 preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。 preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻 一句话总结： webpackChunkName 是为预加载的文件取别名，webpackPrefetch 会在浏览器闲置下载文件，webpackPreload 会在父 chunk 加载时并行下载文件。 4.hash、chunkhash、contenthash 有什么不同？ 首先来个背景介绍，哈希一般是结合 CDN 缓存来使用的。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的 HTML 引用的 URL 地址也会改变，触发 CDN 服务器从源服务器上拉取对应数据，进而更新本地缓存。 hash hash 计算是跟整个项目的构建相关 我们可以发现，生成文件的 hash 和项目的构建 hash 都是一模一样的。 chunkhash 它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。 我们可以看出，chunk 0 的 hash 都是一样的，chunk 1 的 hash 和上面的不一样。 contenthash 我们更近一步，index.js 和 index.css 同为一个 chunk，如果 index.js 内容发生变化，但是 index.css 没有变化，打包后他们的 hash 都发生变化，这对 css 文件来说是一种浪费。 contenthash 将根据资源内容创建出唯一 hash，也就是说文件内容不变，hash 就不变。 可以看出，当仅js文件改变时，css文件的hash值没有变化。 Webpack工作流程 1、读取配置文件，按命令 初始化 配置参数，创建 Compiler 对象； 2、调用插件的 apply 方法 挂载插件 监听，然后从入口文件开始执行编译； 3、按文件类型，调用相应的 Loader 对模块进行 编译，并在合适的时机点触发对应的事件，调用 Plugin 执行，最后再根据模块 依赖查找 到所依赖的模块，递归执行第三步； 4、将编译后的所有代码包装成一个个代码块 (Chuck)， 并按依赖和配置确定 输出内容。这个步骤，仍然可以通过 Plugin 进行文件的修改; 5、最后，根据 Output 把文件内容一一写入到指定的文件夹中，完成整个过程； "},"前端/webpack/配置.html":{"url":"前端/webpack/配置.html","title":"配置","keywords":"","body":"target 告知 webpack 为目标(target)指定一个环境。常见如node、web。 resolve常用配置 resolve设置模块如何被解析。 webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。 resolve.alias 创建 import 或 require 的别名，来确保模块引入变得更简单。 // Node.js中提供了两个与文件操作相关全局可用变量__dirname和__filename // __dirname表示当前文件所在的目录，__filename表示正在执行脚本的文件名。 function resolve (dir) { return path.join(__dirname, '..', dir) } module.exports = { //... resolve: { alias: { '@': resolve('src'), } } }; resolve.extensions 自动解析确定的扩展，能够使用户在引入模块时不带扩展。默认为['.js', '.json']。 添加less后缀，是否也可以不用写less了，umi可能修改了此配置 resolve.mainFields 当从 npm 包中导入模块时（例如，import * as D3 from \"d3\"） ，决定在 package.json 中使用哪个字段导入模块。根据 webpack 配置中指定的 target 不同，默认值也会有所不同。 target为web默认值为 ['browser', 'module', 'main'] resolve.mainFiles 解析目录时要使用的文件名，默认mainFiles: [\"index\"] 这也是在React开发中，我们创建一个目录，在目录中创建index.js，我们只需要import这个目录即可 resolve.modules 告诉 webpack 解析模块时应该搜索的目录。默认是node_modules。 modules: [\"node_modules\"] module常用配置 module指示如何处理项目中的不同类型模块。 module.noParse 防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的 library 可以提高构建性能。 module.exports = { //... module: { noParse: /jquery|lodash/, } }; module.rules 创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。配置loader的地方，是一个对象数组，每一项test表适配的文件类型表达式，use表对应的解析器。 module.exports = { //... rules: [ { test: /.css$/, use: 'url-loader' }, // ... ] }; ===================old=================== externals 打包文件排除某些依赖，而依赖用户的环境。 index.html中来自cdn的jquery webpack中的配置 module.exports = { //... externals: { jquery: 'jQuery' } }; devtool source map的配置... watch & watchOptions webpack 可以监听文件变化，当它们修改后会重新编译。 devServer 来自webpack-dev-server的选项 devServer.before 在服务内部的所有其他中间件之前， 提供执行自定义中间件的功能。 module.exports = { //... devServer: { before: function(app, server) { app.get('/some/path', function(req, res) { res.json({ custom: 'response' }); }); } } }; devServer.proxy module.exports = { //... devServer: { proxy: { '/api': 'http://localhost:3000' } } }; 请求到 /api/users 现在会被代理到请求 http://localhost:3000/api/users。 如果你不想始终传递 /api ，则需要重写路径： module.exports = { //... devServer: { proxy: { '/api': { target: 'http://localhost:3000', pathRewrite: {'^/api' : ''} } } } }; "},"前端/webpack/plugin.html":{"url":"前端/webpack/plugin.html","title":"plugin","keywords":"","body":"如何编写一个插件 webpack 插件由以下组成： 一个 JavaScript 命名函数。 在插件函数的 prototype 上定义一个 apply 方法。 指定一个绑定到 webpack 自身的事件钩子。 处理 webpack 内部实例的特定数据。 功能完成后调用 webpack 提供的回调。 // 一个 JavaScript 命名函数。 function MyExampleWebpackPlugin() { }; // 在插件函数的 prototype 上定义一个 `apply` 方法。 MyExampleWebpackPlugin.prototype.apply = function(compiler) { // 指定一个挂载到 webpack 自身的事件钩子。 // compilation: 处理 webpack 内部实例的特定数据 // TODO: 有空可以打印出compilation看看 compiler.plugin('webpacksEventHook', function(compilation, callback) { console.log(\"This is an example plugin!!!\"); // 功能完成后调用 webpack 提供的回调。 callback(); }); }; Compiler 和 Compilation 在插件开发中最重要的两个资源就是 compiler 和 compilation 对象。理解它们的角色是扩展 webpack 引擎重要的第一步。 compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。 compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。 常用的plugin 何为插件(Plugin)？专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。 Plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。 HotModuleReplacementPlugin 模块热更新插件。Hot-Module-Replacement 的热更新是依赖于 webpack-dev-server，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，HRM 是只更新修改的部分。 HotModuleReplacementPlugin是webpack模块自带的，所以引入webpack后，在plugins配置项中直接使用即可。 html-webpack-plugin 生成 html 文件。将 webpack 中entry配置的相关入口 chunk 和 extract-text-webpack-plugin抽取的 css 样式 插入到该插件提供的template或者templateContent配置项指定的内容基础上生成一个 html 文件，具体插入方式是将样式link插入到head元素中，script插入到head或者body中。 const HtmlWebpackPlugin = require('html-webpack-plugin') plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.join(__dirname, '/index.html'), minify: { removeComments: true, // 移除HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true, // 压缩内联css }, inject: true, }), ] 多页应用打包，指定多个HtmlWebpackPlugin，然后指定其依赖的chunks module.exports = { //... plugins: [ new HtmlWebpackPlugin({ template: './public/index.html', filename: 'index.html', //打包后的文件名 chunks: ['index'], }), new HtmlWebpackPlugin({ template: './public/login.html', filename: 'login.html', //打包后的文件名 chunks: ['login'], }), ], } clean-webpack-plugin clean-webpack-plugin 用于在打包前清理上一次项目生成的 bundle 文件，它会根据 output.path 自动清理文件夹；这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，导致文件夹非常庞大。 extract-text-webpack-plugin 将 css 成生文件，而非内联 。该插件的主要是为了抽离 css 样式，防止将样式打包在 js 中引起页面样式加载错乱的现象。 这个还在使用么？所有的样式都抽离到一个文件？ const ExtractTextPlugin = require('extract-text-webpack-plugin') plugins: [ // 将css分离到/dist文件夹下的css文件夹中的index.css new ExtractTextPlugin('css/index.css'), ] mini-css-extract-plugin 将 CSS 提取为独立的文件的插件，对每个包含 css 的 js 文件都会创建一个 CSS 文件，支持按需加载 css 和 sourceMap。只能用在 webpack4 中，对比另一个插件 extract-text-webpack-plugin 有以下特点: 异步加载 不重复编译，性能更好 更容易使用 只针对 CSS 这个插件应该只用在生产环境配置，并且在 loaders 链中不使用 style-loader, 而且这个插件暂时不支持 HMR const MiniCssExtractPlugin = require('mini-css-extract-plugin') module.exports = { module: { rules: [ { test: /\\.(less|css)$/, use: [ { loader: MiniCssExtractPlugin.loader, options: { publicPath: '../', }, }, 'css-loader', 'postcss-loader', 'less-loader', ], }, ], }, plugins: [ new MiniCssExtractPlugin({ filename: 'css/[name].[contenthash:8].css', chunkFilename: 'css/[id].[contenthash:8].css', }), ], } optimize-css-assets-webpack-plugin 我们希望减小 css 打包后的体积，可以用到 optimize-css-assets-webpack-plugin。 const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\") optimization: { minimizer: [ // 压缩css new OptimizeCSSAssetsPlugin({}) ] } UglifyJsPlugin uglifyJsPlugin 是 vue-cli 默认使用的压缩代码方式，用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度。它使用的是单线程压缩代码，打包时间较慢，所以可以在开发环境将其关闭，生产环境部署时再把它打开。 const UglifyJsPlugin = require('uglifyjs-webpack-plugin') plugins: [ new UglifyJsPlugin({ uglifyOptions: { compress: { warnings: false } }, sourceMap: true, //是否启用文件缓存 parallel: true //使用多进程并行运行来提高构建速度 }) ] terser-webpack-plugin(重点) Webpack4.0 默认是使用 terser-webpack-plugin 这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel 参数，使用多进程压缩，加快压缩。 const TerserPlugin = require('terser-webpack-plugin') // 压缩js代码 optimization: { minimizer: [ new TerserPlugin({ parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1 cache: true, // 是否缓存 sourceMap: false, }), ] } compression-webpack-plugin 所有现代浏览器都支持 gzip 压缩，启用 gzip 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。 gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。 const CompressionPlugin = require('compression-webpack-plugin') plugins: [ new CompressionPlugin({ // gzip压缩配置 test: /\\.js$|\\.html$|\\.css/, // 匹配文件名 threshold: 10240, // 对超过10kb的数据进行压缩 deleteOriginalAssets: false, // 是否删除原文件 }), ] 当然，这个方法还需要后端配置支持。 DefinePlugin 我们可以通过 DefinePlugin 可以定义一些全局的变量，我们可以在模块当中直接使用这些变量，无需作任何声明，DefinePlugin 是 webpack 自带的插件。 plugins: [ new webpack.DefinePlugin({ DESCRIPTION: 'This Is The Test Text.', }), ] // 直接引用 console.log(DESCRIPTION) ProvidePlugin 自动加载模块。 任何时候，当 identifier 被当作未赋值的变量时， module 就会自动被加载，并且 identifier 会被这个 module 输出的内容所赋值。这是 webpack 自带的插件。 module.exports = { resolve: { alias: { jquery: './lib/jquery', }, }, plugins: [ //提供全局的变量，在模块中使用无需用require引入 new webpack.ProvidePlugin({ $: 'jquery', React: 'react', }), ], } DllPlugin（没懂，有时间试下） 这是在一个额外的独立的 webpack 设置中创建一个只有 dll 的 bundle(dll-only-bundle)。 这个插件会生成一个名为 manifest.json 的文件，这个文件是用来让 DLLReferencePlugin 映射到相关的依赖上去的。 使用步骤如下 1、在 build 下创建 webpack.dll.config.js const path = require('path') const webpack = require('webpack') module.exports = { entry: { vendor: [ 'vue-router', 'vuex', 'vue/dist/vue.common.js', 'vue/dist/vue.js', 'vue-loader/lib/component-normalizer.js', 'vue', 'axios', 'echarts', ], }, output: { path: path.resolve('./dist'), filename: '[name].dll.js', library: '[name]_library', }, plugins: [ new webpack.DllPlugin({ path: path.resolve('./dist', '[name]-manifest.json'), name: '[name]_library', }), // 建议加上代码压缩插件，否则dll包会比较大。 new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false, }, }), ], } 2、在 webpack.prod.conf.js 的 plugin 后面加入配置 new webpack.DllReferencePlugin({ manifest: require('../dist/vendor-manifest.json'), }) 3、package.json文件中添加快捷命令(build:dll) \"scripts\": { \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\", \"start\": \"npm run dev\", \"lint\": \"eslint --ext .js,.vue src\", \"build\": \"node build/build.js\", \"build:dll\": \"webpack --config build/webpack.dll.conf.js\" } 复制代码 生产环境打包的时候先npm run build:dll命令会在打包目录下生成 vendor-manifest.json 文件与 vendor.dll.js 文件。然后npm run build生产其他文件。 4、根目录下的入口 index.html 加入引用 copy-webpack-plugin 我们在 public/index.html 中引入了静态资源，但是打包的时候 webpack 并不会帮我们拷贝到 dist 目录，因此 copy-webpack-plugin 就可以很好地帮我做拷贝的工作了。 我们的public资源是不是这个copy过去的？ const CopyWebpackPlugin = require('copy-webpack-plugin') module.exports = { plugins: [ new CopyWebpackPlugin({ patterns: [ { from: 'public/js/*.js', to: path.resolve(__dirname, 'dist', 'js'), flatten: true, }, ], }), ], } IgnorePlugin 这是 webpack 内置插件，它的作用是：忽略第三方包指定目录，让这些指定目录不要被打包进去。 比如我们要使用 moment 这个第三方依赖库，该库主要是对时间进行格式化，并且支持多个国家语言。虽然我设置了语言为中文，但是在打包的时候，是会将所有语言都打包进去的。这样就导致包很大，打包速度又慢。对此，我们可以用 IgnorePlugin 使得指定目录被忽略，从而使得打包变快，文件变小。 const Webpack = require('webpack') plugins: [ // moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去 new Webpack.IgnorePlugin(/\\.\\/locale/, /moment/), ] 我们虽然按照上面的方法忽略了包含’./locale/'该字段路径的文件目录，但是也使得我们使用的时候不能显示中文语言了，所以这个时候可以手动引入中文语言的目录。 import moment from 'moment' //手动引入所需要的语言包 import 'moment/locale/zh-cn' moment.locale('zh-cn') let r = moment().endOf('day').fromNow() console.log(r) "},"前端/webpack/loader.html":{"url":"前端/webpack/loader.html","title":"loader","keywords":"","body":"Loader 由于 Webpack 是基于 Node，因此 Webpack 其实是只能识别 js 模块，比如 css / html / 图片等类型的文件并无法加载，因此就需要一个对 不同格式文件转换器。其实 Loader 做的事，也并不难理解: 对 Webpack 传入的字符串进行按需修改。 Loader 特性: 链式传递，按照配置时相反的顺序链式执行； 基于 Node 环境，拥有 较高权限，比如文件的增删查改； 可同步也可异步； 常用的Loader babel-loader 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题。 步骤如下： babylon 将 ES6/ES7 代码解析成 AST babel-traverse 对 AST 进行遍历转译，得到新的 AST 新 AST 通过 babel-generator 转换成 ES5 file-loader 解析文件的 import/require() ，转换成一个url，并且输出到指定目录。CSS中的url会转换成require。outputPath指的是输出到打包的目录，若使用cdn，需要配置publicPath，公网地址。 url-loader url-loader内部封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader。url-loader工作分两种情况：1.文件大小小于limit参数，url-loader将会把文件转为DataURL；2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。因此我们只需要安装url-loader即可。 expose-loader 暴露模块变量导出到全局，如下配置，则 window.$ 可以使用 require(\"expose-loader?$!jquery\"); 或者 module: { rules: [{ test: require.resolve('jquery'), use: [{ loader: 'expose-loader', options: '$' }] }] } 其他 style-loader: 将 css 代码以style标签的形式插入到 html 中； css-loader: 分析@import和url()，引用 css 文件与对应的资源； postcss-loader: 用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等； less-loader / sass-loader: css预处理器，在 css 中新增了许多语法，提高了开发效率 "},"前端/webpack/优化.html":{"url":"前端/webpack/优化.html","title":"优化","keywords":"","body":"如何减少webpack的打包时间 优化Loader，babel HappyPack DllPlugin 代码压缩 其他： module.extensions resolve.alias module.noparse 如何让webpack打出来的包更小 按需加载 TreeShaking ScopeHosting "},"前端/性能优化/基础.html":{"url":"前端/性能优化/基础.html","title":"基础","keywords":"","body":"概念 DOMContentLoaded https://zhuanlan.zhihu.com/p/25876048 DOMContentLoaded可以看作是网页从空白到出现内容所花费的时间。 当一个 HTML 文档被加载和解析完成后，DOMContentLoaded 事件便会被触发。 Loaded事件是在网页所有内容加载完毕后触发。 MDN：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。另一个不同的事件 load应该仅用于检测一个完全加载的页面。 这里有一个常见的错误，就是在本应使用 DOMContentLoaded 会更加合适的情况下，却选择使用 load，所以要谨慎。注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。 注意上面最后一句话：必须等待所属script之前的样式表加载解析完成才会触发。 解析过程如下： 普通脚本 当 HTML 文档被解析时如果遇见（同步）脚本，则停止解析，先去加载脚本，然后执行，执行结束后继续解析 HTML 文档。 Defer脚本 当 HTML 文档被解析时如果遇见 defer 脚本，则在后台加载脚本，文档解析过程不中断，而等文档解析结束之后，defer 脚本执行（延迟执行）。另外，defer 脚本的执行顺序与定义时的位置有关。 defer标签的脚本不会影响 HTML 文档的解析，而是等到 HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。 所以这意味着什么呢？HTML 文档解析不受影响，等 DOM 构建完成之后 defer 脚本执行，但脚本执行之前需要等待 CSSOM 构建完成。在 DOM、CSSOM 构建完毕，defer 脚本执行完成之后，DOMContentLoaded 事件触发。 Async脚本 若 HTML 文档被解析时如果遇见 async 脚本，则在后台加载脚本，文档解析过程不中断。脚本加载完成后，文档停止解析，脚本执行，执行结束后文档继续解析。 若HTML 解析完了之后，async脚本才加载完成，不需要等待脚本执行，直接触发DOMContentLoaded事件。 总结 defer和async都会异步加载js，DOMContentLoaded一定会等待defer脚本执行完之后（并且在dom解析完毕之后才执行）才会触发，而async则不会。 "},"前端/性能优化/雅虎军规.html":{"url":"前端/性能优化/雅虎军规.html","title":"雅虎军规","keywords":"","body":"1. 减少HTTP请求数 合并文件，脚本和样式 CSS Sprites 雪碧图，现在还有 SVG Sprites 图像映射，可参考这里 行内图片，base64编码，可写在样式中 2. 减少DNS查询 ​ DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。 ​ DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。 ​ 减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。 也可使用dns-prefetch 3. 避免重定向 HTTP/1.1 301 Moved Permanently Location: http://example.com/newuri Content-Type: text/html 浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。 4. 让Ajax可缓存 这部分内容指，资源文件可缓存，如强制缓存Expires和协商缓存Cache-Control，以及开启Gzip 5. 延迟加载组件 类似懒加载，指加载当前页面需要文件，webpack SplitChunkPlugin 6. 预加载组件 通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。 如下这样可以开启，会在闲时下载 7. 减少DOM元素数量 使用更加语义化的标签 8. 跨域分离组件 分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在www.example.org，而把静态组件分离到static1.example.org和static2.example.org。 9. 尽量少用iframe 用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。 iframe 的优点： 引入缓慢的第三方内容，比如标志和广告 安全沙箱 并行下载脚本 iframe 的缺点： 代价高昂，即使是空白的iframe 阻塞页面加载 非语义 10. 杜绝404 11. 避免CSS表达式 用CSS表达式动态设置CSS属性，是一种强大又危险的方式。 background-color: expression( (new Date()).getHours()%2 ? \"#B8D4FF\" : \"#F08A00\" ); 12. 选择link舍弃@import 前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。 13.避免使用滤镜 14. 把样式表放在顶部 我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。 15. 去除重复脚本 16. 尽量减少DOM的访问 17. 用智能的时间处理器 * 有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。 18.把脚本放在底部 19. 把JavaScript和CSS放到外面 意思就是把js和css放在单独文件中 20. 压缩JavaScript和CSS minify 和 compress 21. 优化图片 图片转换成png 22. 优化CSS Sprite 不要留太大间隙 23. 不要用HTML缩放图片 尽量使用合适大小的图像，而不是去压缩 24.用小的可缓存的favicon.ico favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。 25. 给Cookie减肥 使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。 26. 把组件放在不含cookie的域下 * 当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。 27. 保证所有组件都小于25K 这个限制是因为iPhone不能缓存大于25K的组件， 不懂这个 28. 把组件打包到一个复合文档里 把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件 。 意思是一个请求就能下载很多包？ 29. Gzip组件 压缩可以通过减少HTTP响应的大小来缩短响应时间。 从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。 Accept-Encoding: gzip, deflate 如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。 Content-Encoding: gzip 尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。 30. 避免图片src属性为空 Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现： HTML JavaScript var img = new Image(); img.src = \"\"; 这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。 引出另外一个问题：若img标签display为none，是否也会发送请求？ 答案：也会发送 31. 配置ETags 源服务器用相应头中的ETag来指定组件的ETag HTTP/1.1 200 OK Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT ETag: \"10c24bc-4ab-457e1c1f\" Content-Length: 12195 再次请求时返回 304 GET /i/yahoo.gif HTTP/1.1 Host: us.yimg.com If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT If-None-Match: \"10c24bc-4ab-457e1c1f\" HTTP/1.1 304 Not Modified 32. 对Ajax用GET请求 33. 尽早清空缓冲区 34. 使用CDN（内容分发网络） 内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。 35. 添上Expires或者Cache-Control HTTP头 相当于使用缓存 "},"前端/性能优化/React性能优化.html":{"url":"前端/性能优化/React性能优化.html","title":"React 性能优化","keywords":"","body":"代码分割 官网(这里)推荐是用 React.lazy const OtherComponent = React.lazy(() => import('./OtherComponent')); React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件。 然后应在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。 import React, { Suspense } from 'react'; const OtherComponent = React.lazy(() => import('./OtherComponent')); function MyComponent() { return ( Loading...}> ); } React.lazy 和 Suspense 技术还不支持服务端渲染。如果你想要在使用服务端渲染的应用中使用，我们推荐 Loadable Components 这个库。它有一个很棒的服务端渲染打包指南。 需要依赖如下babel插件，preset-reset应该默认包含吧 \"plugins\": [\"@babel/plugin-syntax-dynamic-import\"] 基于路由的代码分割 React.lazy版本 import React, { Suspense, lazy } from 'react'; import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'; const Home = lazy(() => import('./routes/Home')); const About = lazy(() => import('./routes/About')); const App = () => ( Loading...}> ); loadable 版本 import loadable from \"@loadable/component\"; import Loading from \"./Loading.js\"; const LoadableComponent = loadable(() => import(\"./Dashboard.js\"), { fallback: }); export default class LoadableDashboard extends React.Component { render() { return ; } } "},"源码/redux-4.0.5.html":{"url":"源码/redux-4.0.5.html","title":"redux 4.0.5","keywords":"","body":"本文是基于redux 4.0.5的源码做的解析，源码不多，目录结构如下所示： utils actionTypes.js const randomString = () => Math.random() .toString(36) .substring(7) .split('') .join('.') const ActionTypes = { INIT: `@@redux/INIT${randomString()}`, REPLACE: `@@redux/REPLACE${randomString()}`, PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}` } export default ActionTypes 该文件首先定义了一个产生随机数的函数，然后定义了三个内部使用的ActionType。 isPlainObject.js export default function isPlainObject(obj) { if (typeof obj !== 'object' || obj === null) return false let proto = obj while (Object.getPrototypeOf(proto) !== null) { proto = Object.getPrototypeOf(proto) } return Object.getPrototypeOf(obj) === proto } 判断是否是一个简单对象，什么是简单对象呢？就是由Object构造函数或者字面量方式创建的对象，即obj.__proto__ === Object.protype 。 我的解读：上面的意思是一个对象的原型链深度只有一层，一般情况下只有Object才能满足，但可以人为创建一个原型为null的构造函数来终止原型链。 我们可以先看下 lodash 中 isPlainObject 的解释： _.isPlainObject(value) Checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null. 也就是说由Object创建的对象或者字面量对象，以及由没有原型的构造函数所创建 _.isPlainObject([1, 2, 3]); // => false _.isPlainObject({ 'x': 0, 'y': 0 }); // => true _.isPlainObject(Object.create(null)); // => true // 补充：Object.create对应的原理如下，即创建一个对象以参数为原型 Object.create = function (o) { var F = function () {}; F.prototype = o; return new F(); }; 只不过这里有点疑问，为什么不能这么写呢？ const proto = Object.getPrototypeOf(obj); return proto === Object.prototype || proto === null warning.js 打印错误信息，适配了console在ie低版本中的兼容性问题 index.js import createStore from './createStore' import combineReducers from './combineReducers' import bindActionCreators from './bindActionCreators' import applyMiddleware from './applyMiddleware' import compose from './compose' import warning from './utils/warning' import __DO_NOT_USE__ActionTypes from './utils/actionTypes' // 省去非重要的代码 export { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, __DO_NOT_USE__ActionTypes } 该文件是整个redux的入口文件，暴露了很多方法，每个方法都在对应的文件中，我们一个个的看。 createStore.js export default function createStore(reducer, preloadedState, enhancer) { // ... 省略部分代码 let currentReducer = reducer // 当前的reducer let currentState = preloadedState // store的当前状态 let currentListeners = [] // 当前订阅列表 let nextListeners = currentListeners // 新的订阅列表 let isDispatching = false // 作为锁来用 // ... 省略了需要到处的函数定义 dispatch({ type: ActionTypes.INIT }) return { dispatch, subscribe, getState, replaceReducer, [$$observable]: observable } } 由此可见，createStore创建了一个闭包环境，暴露了一些操作内部遍历的函数。createStore的前两个参数很好理解，第三个参数enhancer意思为增强器，来增强redux的，下面将会介绍。 createStore也适配了两个参数的情形，第二个参数可以忽略，代码如下： if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') { enhancer = preloadedState preloadedState = undefined } getState function getState() { if (isDispatching) { throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) } // 由此可看出，此处直接返回了内部对象，非副本，理论上可修改内部state，但是不会进行事件通知 return currentState } 可以看到，当在进行reducer操作时获取state，则会报错。该函数直接返回内部状态currentState，并没有做拷贝动作，因此这里得到的state是可以被更改的，但是redux不允许这么做。 dispatch function dispatch(action) { // 省略代码：判断是否是plainObject，判断action是否有type属性 if (isDispatching) { throw new Error('Reducers may not dispatch actions.') } try { isDispatching = true currentState = currentReducer(currentState, action) } finally { isDispatching = false } // 通知每一个listener // 注意currentListeners = nextListeners这一步操作，后面会提到 const listeners = (currentListeners = nextListeners) for (let i = 0; i 可以看到dispatch实际上就是就是调用reducer，然后通知所有订阅的监听者，listener是没有回调参数的。同样isDispatch起到锁的作用，当执行reducer时为true。 subscribe function subscribe(listener) { if (typeof listener !== 'function') { throw new Error('Expected the listener to be a function.') } if (isDispatching) { throw new Error('xxx') } // listener的订阅状态 let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() { if (!isSubscribed) { return } if (isDispatching) { throw new Error('xxx') } isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) currentListeners = null } } 可以看出，如果正在执行reducer的时候是不允许进行订阅的。注意该函数的返回值取消该订阅的函数，通过闭包实现。这里需要看下ensureCanMutateNextListeners的实现： function ensureCanMutateNextListeners() { if (nextListeners === currentListeners) { nextListeners = currentListeners.slice() } } 当nextListeners 和 currentListeners为同一引用的时候，则对currentListeners进行一次浅拷贝，保证nextListeners是可以更改的。因为在dispatch的最后，会将currentListeners指向nextListeners，调用所有的监听函数，此时为了保证currentListeners不被修改，乱序导致发生错误，故每当需要对listeners进行修改的时候，均进行一次浅拷贝操作，起到一个缓存的作用，也就是所有的操作针对缓存的，当需要遍历执行的时候，则取最新数据。 replaceReducer 更改reducer，这个方法我们一般很少用到。 function replaceReducer(nextReducer) { if (typeof nextReducer !== 'function') { throw new Error('Expected the nextReducer to be a function.') } currentReducer = nextReducer // This action has a similiar effect to ActionTypes.INIT. // Any reducers that existed in both the new and old rootReducer // will receive the previous state. This effectively populates // the new state tree with any relevant data from the old one. dispatch({ type: ActionTypes.REPLACE }) } ActionTypes.INIT 在createStore函数的末尾我们可以看到，dispatch了这样的一个action dispatch({ type: ActionTypes.INIT }) 是因为我们的初始状态currentState为undefined，发了这样一个action是为了拿到state的初始状态对象。 applyMiddleware & enhancer 这部分是Redux的精华，也是十分难以理解的地方。重点理解。 通过enhancer的调用方式enhancer(createStore)(reducer, preloadedState)，我们可以看出，enhancer是返回一个以createStore为参数的加强版本的createStore函数。而applyMiddleware就是用来适配middleware返回enhancer函数的。 最难理解的一个函数， export default function applyMiddleware(...middlewares) { // 返回一个高阶函数 return createStore => (...args) => { const store = createStore(...args) let dispatch = () => { throw new Error( 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.' ) } const middlewareAPI = { getState: store.getState, dispatch: (...args) => dispatch(...args) } const chain = middlewares.map(middleware => middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) // applyMiddleware主要是对dispatch的装饰 return { ...store, dispatch } } } 温习一下compose函数： compose(f, g) = (...args) => f(g(..args)); // 这里我们把参数换成next，next可以认为是增强版本的dispatch函数 compose(f, g) = next => f(g(next)); 现在看如下两行关键代码： // 一个中间件最简单的形式：store => next => action => next(action) // 通过如下一层计算，每个函数变成：next => action => next(action) // 即传入一个dispatch函数，返回一个dispatch函数 const chain = middlewares.map(middleware => middleware(middlewareAPI)) // 如下这句代码可以看作通过中间件对dispatch函数做了层层增强后的dispatch函数 // next可看作是上一个中间件修饰生成的dispatch函数，初始的next函数就是store.dispatch // dispatch修饰是从右到左，dispatch的执行是从左到右 dispatch = compose(...chain)(store.dispatch) combineReducers.js 参数reducers是一个对象，类似如下形式，返回一个新的代理所有reducers的函数。 { key1: reducer1(), key2: reducer2() } 代码如下，只保留关键代码： export default function combineReducers(reducers) { const reducerKeys = Object.keys(reducers) const finalReducers = {} // 找出所有是函数的reducer for (let i = 0; i compose.js 组合函数 export default function compose(...funcs) { if (funcs.length === 0) { return arg => arg } if (funcs.length === 1) { return funcs[0] } return funcs.reduce((a, b) => (...args) => a(b(...args))) } bindActionCreators.js 这是一个辅助函数，可以将一个actionCreators映射成一个个自动dispatch的函数 function bindActionCreator(actionCreator, dispatch) { return function() { return dispatch(actionCreator.apply(this, arguments)) } } export default function bindActionCreators(actionCreators, dispatch) { if (typeof actionCreators === 'function') { return bindActionCreator(actionCreators, dispatch) } const boundActionCreators = {} for (const key in actionCreators) { const actionCreator = actionCreators[key] if (typeof actionCreator === 'function') { boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) } } return boundActionCreators } redux-thunk 源码 function createThunkMiddleware(extraArgument) { return ({ dispatch, getState }) => (next) => (action) => { if (typeof action === 'function') { return action(dispatch, getState, extraArgument); } // next可看作是上一个中间件修饰生成的dispatch函数 return next(action); }; } const thunk = createThunkMiddleware(); thunk.withExtraArgument = createThunkMiddleware; export default thunk; "},"源码/react-redux-7.2.0.html":{"url":"源码/react-redux-7.2.0.html","title":"react redux 7.2.0","keywords":"","body":"使用 Redux 有Redux源码可知，其核心在于createStore函数，并返回一个api对象 export default function createStore(reducer, preloadedState, enhancer) { // ... return { dispatch, subscribe, getState, replaceReducer, [$$observable]: observable } } 使用方式如下： // store.js import { createStore } from 'redux' // 3. 下面store每dispatch一次reducer就会重新执行并计算一次state function reducer(state = {a: 1}, action) { const { type, payload } = action return payload } // 0. 创建一个store const store = createStore(reducer) // 1. 监听store中state的变更 store.subscribe((state) => { console.log(state) }) // 2. 发送一个action来通知reducer修改state // {type: 'type1', payload: 1} 就是一个ation store.dispatch({ type: 'type1', payload: {a: 2} }) React Redux import { Provider } from 'react-redux' // redux方式创建一个store import store from './store' import App from './App.js' // 通过Provider组件注入到Context中，然后各组件通过connect高阶组件连接 ReactDOM.render() connect mapStateToProps 两个参数，第二个参数意义？ mapStateToProps(state, ownProps) ownProps: 如果你的组件需要用自身的props数据以从store中检索出数据，你可以传入第二个参数，ownProps。这个参数将包含所有传递给由connect生成的包装组件的props。 mapDispatchToProps actionCreators "},"源码/react-router-5.1.2.html":{"url":"源码/react-router-5.1.2.html","title":"react router 5.1.2","keywords":"","body":"使用方式 实现路由的两种方法：hash和H5 History API BrowserRouter基于history的pushState和popState HashRouter基于location.hash和hashchange事件 使用了history这个库来监听路由变化 history库 history源码解析-管理会话历史记录 手把手带你上react-router的history车 history有三种方法创建history对象 createBrowserHistory：支持h5 history api的现代浏览器 createHashHistory：传统浏览器 /#/index createMemoryHistory ：Node, React Native HTML5 history && location对象字段 // https://www.baidu.com/dd?page=2#1321321 const location = { origin: \"https://www.baidu.com\" protocol: \"https:\" host: \"www.baidu.com\" hostname: \"www.baidu.com\" port: \"\" pathname: \"/dd\" search: \"?page=2\" hash: \"#1321321\" href: \"https://www.baidu.com/dd?page=2#1321321\" } const history = { length, // 属性，history历史栈中的数量 state, // 属性，pushState和replaceState时传入的对象 back, // 方法，后退 forward, // 方法，前进 go, // 方法，前进或后退n个记录 pushState, // 方法，导航到新的路由，并记录在history中 replaceState // 方法，替换掉当前记录在history中的路由信息 } // 调用history.pushState()或者history.replaceState()不会触发popstate事件. // popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮， // 或者在JavaScript中调用history.back()、history.forward()、history.go()方法. window.onpopstate = function (event) {} // window.onhashchange：当前 URL 的锚部分(以 '#' 号为开始) 发生改变时触发 // a、通过设置Location 对象 的 location.hash 或 location.href 属性修改锚部分; // b、使用不同history操作方法到带hash的页面; // c、点击链接跳转到锚点。 window.onhashchange = function (event) {} history库中的history和location对象 const history = { length, // 属性，history中记录的state的数量 action, // 属性，当前导航的action类型 location, // 属性，location对象，封装了pathname、search和hash等属性 createHref, // push, // 方法，导航到新的路由，并记录在history中 replace, // 方法，替换掉当前记录在history中的路由信息 go, // 方法，前进或后退n个记录 goBack, // 方法，后退 goForward, // 方法，前进 canGo, // 方法，是否能前进或后退n个记录 block, // 方法，跳转前让用户确定是否要跳转 listen // 方法，订阅history变更事件 }; createBrowserHistory.js 返回history对象 function createBrowserHistory(props = {}) { ... const history = { length: globalHistory.length, action: 'POP', location: initialLocation, createHref, push, replace, go, goBack, goForward, block, listen }; return history; } location对象 React-Router-Dom React Router源码浅析 React-Router-Config "},"后端/SUMMARY.html":{"url":"后端/SUMMARY.html","title":"后端","keywords":"","body":" Java 算法 设计模式 架构 maven "},"DevOps/SUMMARY.html":{"url":"DevOps/SUMMARY.html","title":"DevOps","keywords":"","body":" git "},"DevOps/nginx.html":{"url":"DevOps/nginx.html","title":"nginx","keywords":"","body":"root，alias 作用 try files "}}