对于选型，很同意如下作者的一段话：

https://zhuanlan.zhihu.com/p/62338731

> 谈人生，谈情怀，我觉得过程很重要。但对于工作，我只以结果为导向。我从来对任何技术没有什么偏见，但我唯一珍惜的是我的时间。如果能用原生开发解决的问题，我绝对不会花成本去学习第三方框架。如果能用Python解决的问题，我100%不会用Java来写。
>
> 
>
> 第三方框架的存在是有价值的，它确实解决了不少人的需求，但我不建议大家盲从。如果一个框架你根本不知道你为什么用它，那还是用原生吧，最省心的选择。
>
> 
>
> 同学们也不要忽略了这个一点：用第三方框架就完全不需要学习原生小程序吗？这当然是不可能的，正是因为用了第三方框架，你反而要更加精通原生小程序的开发。不然你怎么解决各个第三方框架的”坑“？没有哪个框架能100%保证完美转译成小程序的。至少最近团队在处理LinUI的时候就发现，很多框架都宣传支持小程序的自定义组件，然而我们用第三方测试的结果是，这些框架根本无法编译小程序的WXS。

如果连原生框架都搞不懂，那么使用框架的话，后面会有很多坑需要你去填补。



# 原生小程序

小程序特点

- 网页开发渲染线程和脚本线程是互斥的，而在小程序中，二者是分开的，分别运行在不同的线程中

- 小程序没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API，很多库无法运行。
- 小程序只需要考虑Android/iOS两大客户端，而不关注各浏览器兼容性问题。



小程序原理

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（Native）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。

![img](小程序.assets/4-1.ad156d1c.png)

场景值：场景值用来描述用户进入小程序的路径。即何种方式进入小程序。



**注册小程序**

每个小程序都需要在 `app.js` 中调用 `App` 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。

```js
// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})
```

整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 `getApp` 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 `App` 上的函数。



**注册页面**

对于小程序中的每个页面，都需要在页面对应的 `js` 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。

简单的页面可以使用 `Page()` 进行构造。

`Page` 构造器适用于简单的页面。但对于复杂的页面， `Page` 构造器可能并不好用。

此时，可以使用 `Component` 构造器来构造页面。 `Component` 构造器的主要区别是：方法需要放在 `methods: { }` 里面。



**页面生命周期**

![img](小程序.assets/page-lifecycle.2e646c86.png)



# Taro

入口组件

onLaunch

componentDidShow

componentDidHide

onPageNotFound 程序要打开的页面不存在



页面组件



Taro由来及原理

https://taro-docs.jd.com/taro/blog/2018-06-25-the-birth-of-taro#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83

 `babel` 的核心编译器 `babylon` 是支持对 `JSX` 语法的解析的，我们可以直接利用它来帮我们构造 AST

`JSX` 的写法极其灵活多变，我们只能通过穷举的方式，将常用的、React 官方推荐的写法作为转换规则加以支持，**而一些比较生僻的，或者是不那么推荐的写的写法则不做支持，转而以 `eslint` 插件的方式，提示用户进行修改**。目前我们支持的 `JSX` 转换规则，大致能覆盖到 `JSX` 80% 的写法操作。